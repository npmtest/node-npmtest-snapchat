{"/home/travis/build/npmtest/node-npmtest-snapchat/test.js":"/* istanbul instrument in package npmtest_snapchat */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-snapchat/lib.npmtest_snapchat.js":"/* istanbul instrument in package npmtest_snapchat */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_snapchat = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_snapchat = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-snapchat/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-snapchat && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_snapchat */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_snapchat\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_snapchat.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_snapchat.rollup.js'] =\n            local.assetsDict['/assets.npmtest_snapchat.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_snapchat.__dirname + '/lib.npmtest_snapchat.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/index.js":"module.exports = Snapchat\n\n// external\nvar debug = require('debug')('snapchat')\nvar phone = require('phone')\nvar zlib = require('zlib')\nvar Promise = require('bluebird')\n\n// utilities\nvar constants = require('./lib/constants')\nvar Request = require('./lib/request')\nvar StringUtils = require('./lib/string-utils')\n\n// routes\nvar Account = require('./routes/account')\nvar Chat = require('./routes/chat')\nvar Device = require('./routes/device')\nvar Friends = require('./routes/friends')\nvar Snaps = require('./routes/snaps')\nvar Stories = require('./routes/stories')\n\n// models\nvar Session = require('./models/session')\n\n/**\n * Snapchat Client\n *\n * @class\n * @param {Object} opts (currently unused)\n */\nfunction Snapchat (opts) {\n  var self = this\n  if (!(self instanceof Snapchat)) return new Snapchat(opts)\n  if (!opts) opts = {}\n\n  debug('new snapchat client')\n\n  self._account = new Account(self, opts)\n  self._chat = new Chat(self, opts)\n  self._device = new Device(self, opts)\n  self._friends = new Friends(self, opts)\n  self._snaps = new Snaps(self, opts)\n  self._stories = new Stories(self, opts)\n}\n\n/**\n * Account routes.\n *\n * @name Snapchat#account\n * @property {Account}\n * @readonly\n */\nObject.defineProperty(Snapchat.prototype, 'account', {\n  get: function () { return this._account }\n})\n\n/**\n * Chat routes.\n *\n * @name Snapchat#chat\n * @property {Chat}\n * @readonly\n */\nObject.defineProperty(Snapchat.prototype, 'chat', {\n  get: function () { return this._chat }\n})\n\n/**\n * Device routes.\n *\n * @name Snapchat#device\n * @property {Device}\n * @readonly\n */\nObject.defineProperty(Snapchat.prototype, 'device', {\n  get: function () { return this._device }\n})\n\n/**\n * Friend routes.\n *\n * @name Snapchat#friends\n * @property {Friends}\n * @readonly\n */\nObject.defineProperty(Snapchat.prototype, 'friends', {\n  get: function () { return this._friends }\n})\n\n/**\n * Snap routes.\n *\n * @name Snapchat#snaps\n * @property {Snaps}\n * @readonly\n */\nObject.defineProperty(Snapchat.prototype, 'snaps', {\n  get: function () { return this._snaps }\n})\n\n/**\n * Story routes.\n *\n * @name Snapchat#stories\n * @property {Stories}\n * @readonly\n */\nObject.defineProperty(Snapchat.prototype, 'stories', {\n  get: function () { return this._stories }\n})\n\n/**\n * The username of the currently signed in (or not yet singed in) user.\n * (Always lowercase)\n *\n * @name Snapchat#username\n * @property {string}\n */\nObject.defineProperty(Snapchat.prototype, 'username', {\n  get: function () {\n    var self = this\n    return self._username\n  }\n})\n\n/**\n * The username of the currently signed in (or not yet singed in) user.\n * @note Always lowercase.\n *\n * @name Snapchat#session\n * @property {Session}\n */\nObject.defineProperty(Snapchat.prototype, 'session', {\n  get: function () {\n    var self = this\n    return self._session\n  },\n\n  set: function (session) {\n    var self = this\n    self._session = session\n\n    if (session) {\n      self._username = session.username\n      self._authToken = session.authToken\n    } else {\n      self._username = null\n      self._authToken = null\n    }\n  }\n})\n\n/**\n * The size of your device's screen.\n *\n * @name Snapchat#screenSize\n * @property {Object}\n */\nObject.defineProperty(Snapchat.prototype, 'screenSize', {\n  get: function () {\n    var self = this\n    return self._screenSize\n  }\n})\n\n/**\n * The maximum size to load videos in.\n *\n * @name Snapchat#maxVideoSize\n * @property {Object}\n */\nObject.defineProperty(Snapchat.prototype, 'maxVideoSize', {\n  get: function () {\n    var self = this\n    return self._maxVideoSize\n  }\n})\n\n/**\n * Whether or not this client is signed in.\n *\n * @name Snapchat#isSignedIn\n * @property {boolean}\n */\nObject.defineProperty(Snapchat.prototype, 'isSignedIn', {\n  get: function () {\n    var self = this\n    return self._googleAuthToken && self._authToken && self._username\n  }\n})\n\n/**\n * Used internally to sign in.\n *\n * @name Snapchat#authToken\n * @property {string}\n */\nObject.defineProperty(Snapchat.prototype, 'authToken', {\n  get: function () {\n    var self = this\n    return self._authToken\n  }\n})\n\n/**\n * Used internally to sign in.\n *\n * @name Snapchat#googleAuthToken\n * @property {string}\n */\nObject.defineProperty(Snapchat.prototype, 'googleAuthToken', {\n  get: function () {\n    var self = this\n    return self._googleAuthToken\n  }\n})\n\n/**\n * Used internally.\n *\n * @name Snapchat#deviceToken1i\n * @property {string}\n */\nObject.defineProperty(Snapchat.prototype, 'deviceToken1i', {\n  get: function () {\n    var self = this\n    return self._deviceToken1i\n  }\n})\n\n/**\n * Used internally.\n *\n * @name Snapchat#deviceToken1v\n * @property {string}\n */\nObject.defineProperty(Snapchat.prototype, 'deviceToken1v', {\n  get: function () {\n    var self = this\n    return self._deviceToken1v\n  }\n})\n\n/**\n * Used internally to sign in and trick Snapchat into thinking we're using the first party client.\n *\n * @name Snapchat#googleAttestation\n * @property {string}\n */\nObject.defineProperty(Snapchat.prototype, 'googleAttestation', {\n  get: function () {\n    var self = this\n    return self._googleAttestation\n  }\n})\n\n/**\n * Signs into Snapchat.\n *\n * A valid GMail account is necessary to trick Snapchat into thinking we're using the first party client.\n *\n * Note that username, password, gmailEmail, and gmailPassword are all optional only if\n * their environment variable equivalents exist. E.g.,\n *\n * SNAPCHAT_USERNAME\n * SNAPCHAT_PASSWORD\n * SNAPCHAT_GMAIL_EMAIL\n * SNAPCHAT_GMAIL_PASSWORD\n *\n * @param {string} Optional username The Snapchat username to sign in with.\n * @param {string} Optional password The password to the Snapchat account to sign in with.\n * @param {string} Optional gmailEmail A valid GMail address.\n * @param {string} Optional gmailPassword The password associated with gmailEmail.\n * @param {function} cb\n */\nSnapchat.prototype.signIn = function (username, password, gmailEmail, gmailPassword, cb) {\n  var self = this\n\n  if (typeof username === 'function') {\n    cb = username\n    username = process.env.SNAPCHAT_USERNAME\n    password = process.env.SNAPCHAT_PASSWORD\n    gmailEmail = process.env.SNAPCHAT_GMAIL_EMAIL\n    gmailPassword = process.env.SNAPCHAT_GMAIL_PASSWORD\n  }\n\n  return new Promise(function (resolve, reject) {\n    if (!(username && password && gmailEmail && gmailPassword)) {\n      return reject(new Error('missing required login credentials'))\n    }\n\n    debug('Snapchat.signIn (username %s)', username)\n\n    self._getGoogleAuthToken(gmailEmail, gmailPassword, function (err, googleAuthToken) {\n      if (err) {\n        debug('error getting google auth token')\n        return reject(err)\n      }\n\n      var timestamp = StringUtils.timestamp()\n\n      self._getAttestation(username, password, timestamp, function (err, attestation) {\n        if (err) {\n          debug('error getting attestation')\n          return reject(err)\n        }\n\n        self._getGoogleCloudMessagingIdentifier(function (err, ptoken) {\n          if (err) {\n            debug('error getting google cloud messaging identifier')\n            return reject(err)\n          }\n\n          self._getDeviceTokens(function (err, deviceTokens) {\n            if (err) {\n              debug('error getting device token')\n              return reject(err)\n            }\n\n            // NOTE: this is a temporary requirement which unfortunately sends\n            // the username and password via plaintext and relies on casper's\n            // servers until we figure out a workaround for generating\n            // X-Snapchat-Client-Auth\n            if (true) {\n              self._getClientAuthToken(username, password, timestamp, function (err, clientAuthToken) {\n                if (err) {\n                  debug('error generating client auth token')\n                  return reject(err)\n                } else {\n                  self.signInWithData(self._makeSignInData(googleAuthToken, attestation, ptoken, clientAuthToken, deviceTokens, timestamp), username, password)\n                  .then(resolve)\n                  .catch(reject)\n                }\n              })\n            } else {\n              self.signInWithData(self._makeSignInData(googleAuthToken, attestation, ptoken, '', deviceTokens, timestamp), username, password)\n              .then(resolve)\n              .catch(reject)\n            }\n          })\n        })\n      })\n    })\n  }).nodeify(cb)\n}\n\nSnapchat.prototype._makeSignInData = function (googleAuthToken, attestation, ptoken, clientAuthToken, deviceTokens, timestamp) {\n  return {\n    googleAuthToken: googleAuthToken,\n    attestation: attestation,\n    pushToken: ptoken,\n    clientAuthToken: clientAuthToken,\n    deviceTokens: deviceTokens,\n    timestamp: timestamp\n  }\n}\n\nSnapchat.prototype.signInWithData = function (data, username, password, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    var googleAuthToken = data.googleAuthToken\n    var attestation = data.attestation\n    var ptoken = data.pushToken\n    var clientAuthToken = data.clientAuthToken\n    var deviceTokens = data.deviceTokens\n    var timestamp = data.timestamp\n\n    self._googleAuthToken = googleAuthToken\n    self._googleAttestation = attestation\n    self._deviceToken1i = deviceTokens[constants.core.deviceToken1i]\n    self._deviceToken1v = deviceTokens[constants.core.deviceToken1v]\n\n    var reqToken = StringUtils.hashSCString(constants.core.staticToken, timestamp)\n    var preHash = StringUtils.getSCPreHashString(username, password, timestamp, reqToken)\n    var deviceHash = StringUtils.hashHMacToBase64(preHash, self._deviceToken1v).substr(0, 20)\n\n    var params = {\n      'username': username,\n      'password': password,\n      'width': constants.screen.width,\n      'height': constants.screen.height,\n      'max_video_width': constants.screen.maxVideoWidth,\n      'max_video_height': constants.screen.maxVideoHeight,\n      'application_id': 'com.snapchat.android',\n      'is_two_fa': 'false',\n      'ptoken': ptoken,\n      'pre_auth': '',\n      'sflag': 1,\n      'dsig': deviceHash,\n      'dtoken1i': self._deviceToken1i,\n      'attestation': self._googleAttestation,\n      'timestamp': timestamp\n    }\n\n    var headers = { }\n    headers[constants.headers.clientAuthToken] = 'Bearer ' + self._googleAuthToken\n    headers[constants.headers.clientAuth] = clientAuthToken\n\n    var opts = {\n      'timestamp': timestamp\n    }\n\n    Request.postCustom(constants.endpoints.account.login, params, headers, null, opts, function (err, result) {\n      if (err) {\n        debug('Snapchat.signIn error %s', err)\n        return reject(err)\n      } else if (result) {\n        self.session = new Session(self, result)\n        return resolve(self.session)\n      }\n\n      err = new Error('Snapchat.signIn parse error')\n      err.data = result\n      return reject(err)\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Use this to restore a session that ended within the last hour. The google auth token must be re-generated every hour.\n *\n * @param {string} username Your Snapchat username.\n * @param {string} authToken Your Snapchat auth token. Can be retrieved from the authToken property.\n * @param {string} googleAuthToken Your Google auth token. Can be retrieved from the googleAuthToken property.\n * @param {function} cb\n */\nSnapchat.prototype.restoreSession = function (username, authToken, googleAuthToken, cb) {\n  var self = this\n  debug('Snapchat.restoreSession (username %s)', username)\n\n  self._username = username\n  self._authToken = authToken\n  self._googleAuthToken = googleAuthToken\n\n  return self.updateSession(cb)\n}\n\n/**\n * Signs out.\n *\n * @param {function} cb\n */\nSnapchat.prototype.signOut = function (cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Snapchat.signOut (%s)', self.username)\n\n    if (!self.isSignedIn) {\n      return reject(new Error('signin required'))\n    }\n\n    self.post(constants.endpoints.account.logout, {\n      'username': self._username\n    }, function (err, result) {\n      if (err) {\n        debug('Snapchat.signOut error %s', err)\n        return reject(err)\n      } else if (result && result.length === 0) {\n        self._session = null\n        self._username = null\n        self._authToken = null\n        self._googleAuthToken = null\n        self._googleAttestation = null\n        self._deviceToken1i = null\n        self._deviceToken1v = null\n        return resolve()\n      }\n      return reject(new Error('Snapchat.signOut parse error'))\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Updates all information in the session property.\n *\n * @param {function} cb\n */\nSnapchat.prototype.updateSession = function (cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Snapchat.updateSession')\n\n    if (!self.isSignedIn) {\n      return reject(new Error('signin required'))\n    }\n\n    self.post(constants.endpoints.update.all, {\n      'username': self._username,\n      'width': constants.screen.width,\n      'height': constants.screen.height,\n      'max_video_width': constants.screen.maxVideoWidth,\n      'max_video_height': constants.screen.maxVideoHeight,\n      'include_client_settings': 'true'\n    }, function (err, result) {\n      if (err) {\n        debug('updateSession error %s', err)\n        return reject(err)\n      } else if (result) {\n        self.session = new Session(self, result)\n        return resolve(self.session)\n      }\n\n      return reject(new Error('updateSession error'))\n    })\n  }).nodeify(cb)\n}\n\n/**\n * The first step in creating a new Snapchat account.\n * Registers an email, password, and birthday in preparation for creating a new account.\n *\n * The result passed to cb has the following keys:\n *  - email: the email you registered with.\n *  - snapchat_phone_number: a number you can use to verify your phone number later.\n *  - username_suggestions: an array of available usernames for the next step.\n *\n * @param {string} email The email address to be associated with the account.\n * @param {string} password The password of the account to be created.\n * @param {string} birthday Your birthday, in the format YYYY-MM-DD.\n * @param {function} cb\n */\nSnapchat.prototype.registerEmail = function (email, password, birthday, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Snapchat.registerEmail (email %s)', email)\n\n    self.post(constants.endpoints.account.registration.start, {\n      'email': email,\n      'password': password,\n      'birthday': birthday\n    }, function (err, result) {\n      if (err) {\n        debug('registerEmail error %s', err)\n        return reject(err)\n      } else if (result && !!result.logged) {\n        return resolve(result)\n      }\n      return reject(new Error('registerEmail parse error'))\n    })\n  }).nodeify(cb)\n}\n\n/**\n * The second step in creating a new Snapchat account.\n * Registers a username with an email that was registered in the first step.\n * You must call this method after successfully completing the first step in registration.\n *\n * @param {string} username The username of the account to be created, trimmed to the first 15 characters.\n * @param {string} registeredEmail The previously registered email address associated with the account (from the first step of registration).\n * @param {string} gmailEmail A valid GMail address. Required to make Snapchat think this is an official client.\n * @param {string} gmailPassword The password to the Google account associated with gmailEmail.\n * @param {function} cb\n */\nSnapchat.prototype.registerUsername = function (username, registeredEmail, gmailEmail, gmailPassword, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Snapchat.registerUsername (username %s, email %s)', username, registeredEmail)\n\n    self._getGoogleAuthToken(gmailEmail, gmailPassword, function (err, googleAuthToken) {\n      if (err) {\n        debug('could not retrieve google auth token')\n        return reject(err)\n      }\n\n      self.post(constants.endpoints.account.registration.username, {\n        'username': registeredEmail,\n        'selected_username': username\n      }, function (err, result) {\n        if (err) {\n          debug('registerUsername error %s', err)\n          return reject(err)\n        } else if (result) {\n          self.session = new Session(self, result)\n          self._googleAuthToken = googleAuthToken\n          return resolve()\n        }\n        return reject(new Error('registerUsername parse error'))\n      })\n    })\n  }).nodeify(cb)\n}\n\n/**\n * The third and final step in registration.\n * If you don't want to verify your humanity a phone number,\n * you can verify it by with a 'captcha' image of sorts.\n *\n * @param {string} mobile A 10-digit (+ optional country code, defaults to 1) mobile phone number to be associated with the account, in any format. i.e. +11234567890, (123) 456-7890, 1-1234567890\n * @param {boolean} sms YES if you want a code sent via SMS, NO if you want to be called for verification.\n * @param {function} cb\n */\nSnapchat.prototype.sendPhoneVerification = function (mobile, sms, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Snapchat.sendPhoneVerification (mobile %s, sms %d)', mobile, sms)\n\n    if (!self.isSignedIn) {\n      return reject(new Error('signin required'))\n    }\n\n    mobile = phone(mobile)\n    var countryCode = +mobile[1]\n    mobile = mobile.substr(2)\n\n    self.post(constants.endpoints.account.registration.verifyPhone, {\n      'username': self._username,\n      'phoneNumber': mobile,\n      'countryCode': countryCode,\n      'action': 'updatePhoneNumber',\n      'skipConfirmation': true\n    }, function (err, result) {\n      if (err) {\n        debug('sendPhoneVerification error %s', err)\n        return reject(err)\n      }\n\n      debug('sendPhoneVerification result %j', result)\n      return resolve(result)\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Verifies your phone number, completing registration.\n *\n * @warning cb is not called in this implementaiton because I haven't tested it yet.\n * @todo: document response, get cb working\n * @param {string} code The code sent to verify your number.\n * @param {function} cb\n*/\nSnapchat.prototype.verifyPhoneNumber = function (code, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Snapchat.verifyPhoneNumber (code %s)', code)\n\n    if (!self.isSignedIn) {\n      return reject(new Error('signin required'))\n    }\n\n    Request.post(constants.endpoints.account.registration.verifyPhone, {\n      'action': 'verifyPhoneNumber',\n      'username': self._username,\n      'code': code\n    }, self._googleAuthToken, constants.core.staticToken, function (err, result) {\n      if (err) {\n        debug('verifyPhoneNumber error %s', err)\n        return reject(err)\n      }\n\n      debug('verifyPhoneNumber result %j', result)\n      return resolve(result)\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Downloads captcha images to verify a new account with.\n * cb will be called with an array of 9 Blobs representing captcha images.\n *\n * @param {function} cb\n */\nSnapchat.prototype.getCaptcha = function (cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Snapchat.getCaptcha')\n\n    if (!self.isSignedIn) {\n      return reject(new Error('signin required'))\n    }\n\n    self.post(constants.endpoints.account.registration.getCaptcha, {\n      'username': self._username\n    }, function (err, body) {\n      if (err) {\n        debug('getCaptcha error %s', err)\n        return reject(err)\n      }\n\n      zlib.gunzip(new Buffer(body), function (err, data) {\n        if (err) {\n          debug('getCaptcha gunzip error %s', err)\n          return reject(err)\n        }\n\n        // TODO\n        return reject(new Error('Snapchat.getCaptcha TODO'))\n      })\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Use this to 'solve' a captcha.\n * @warning Seems to not be working.\n * @todo: document response\n *\n * @param {string} solution The solution to the captcha as a binary string. If the first, second, and last images contain ghosts, the solution would be '110000001'.\n * @param {function} cb\n */\nSnapchat.prototype.solveCaptcha = function (solution, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Snapchat.solveCaptcha')\n\n    if (!self.isSignedIn) {\n      return reject(new Error('signin required'))\n    }\n\n    return reject(new Error('Snapchat.solveCaptcha TODO'))\n  }).nodeify(cb)\n}\n\n/**\n * Initializes a POST request to the Snapchat API.\n *\n * @param {string} endpoint Snapchat API endpoint\n * @param {Object} params Form data (will be augmented with required snapchat API params)\n * @param {function} cb\n */\nSnapchat.prototype.post = function (endpoint, params, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Snapchat.post (%s)', endpoint)\n\n    Request.post(endpoint, params, self._googleAuthToken, self._authToken, function (err, result) {\n      if (err) {\n        return reject(err)\n      }\n      return resolve(result)\n    })\n  }).nodeify(cb)\n}\n\n/**\n * [get description]\n *\n * @param  {string}   endpoint\n * @param  {function} cb\n */\nSnapchat.prototype.get = function (endpoint, cb) {\n  return new Promise(function (resolve, reject) {\n    debug('Snapchat.get (%s)', endpoint)\n\n    Request.get(endpoint, function (err, result) {\n      if (err) {\n        return reject(err)\n      } else {\n        return resolve(result)\n      }\n    })\n  }).nodeify(cb)\n}\n\n/**\n * internal\n */\nSnapchat.prototype.sendEvents = function (events, snapInfo, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Snapchat.sendEvents')\n\n    if (!self.isSignedIn) {\n      return reject(new Error('signin required'))\n    }\n\n    events = events || { }\n    snapInfo = snapInfo || { }\n\n    self._post(constants.endpoints.update.snaps, {\n      'events': events,\n      'json': snapInfo,\n      'username': self._username\n    }, function (err, result) {\n      if (err) {\n        debug('sendEvents error %s', err)\n        return reject(err)\n      }\n\n      debug('sendEvents result %j', result)\n      return resolve(result)\n    })\n  }).nodeify(cb)\n}\n\n/**\n * @private\n */\nSnapchat.prototype._getGoogleAuthToken = function (gmailEmail, gmailPassword, cb) {\n  var encryptedGmailPassword = StringUtils.encryptGmailPassword(gmailEmail, gmailPassword)\n\n  Request.postRaw({\n    url: 'https://android.clients.google.com/auth',\n    form: {\n      'google_play_services_version': '7097038',\n      'device_country': 'us',\n      'operatorCountry': 'us',\n      'lang': 'en_US',\n      'sdk_version': '19',\n      'accountType': 'HOSTED_OR_GOOGLE',\n      'Email': gmailEmail,\n      'EncryptedPasswd': encryptedGmailPassword,\n      // 'Passwd': gmailPassword, // unencrypted version\n      'service': 'audience:server:client_id:694893979329-l59f3phl42et9clpoo296d8raqoljl6p.apps.googleusercontent.com',\n      'source': 'android',\n      'androidId': '378c184c6070c26c',\n      'app': 'com.snapchat.android',\n      'client_sig': '49f6badb81d89a9e38d65de76f09355071bd67e7',\n      'callerPkg': 'com.snapchat.android',\n      'callerSig': '49f6badb81d89a9e38d65de76f09355071bd67e7'\n    },\n    headers: {\n      'device': '378c184c6070c26c',\n      'app': 'com.snapchat.android',\n      'Accept-Encoding': 'gzip',\n      'User-Agent': 'GoogleAuth/1.4 (mako JDQ39)'\n    }\n  }, function (err, response, body) {\n    if (err) {\n      debug('_getGoogleAuthToken error %s', err)\n      return cb(err)\n    } else if (body) {\n      var auth = StringUtils.matchGroup(body, /Auth=([\\w\\.-]+)/i, 1)\n\n      if (auth) {\n        return cb(null, auth)\n      }\n    }\n\n    return cb('Snapchat._getGoogleAuthToken unknown error')\n  })\n}\n\n// static cache of device tokens\nvar sDeviceToken1i = null\nvar sDeviceToken1v = null\n\n/**\n * @private\n */\nSnapchat.prototype._getDeviceTokens = function (cb) {\n  // cache device tokens\n  var dt1i = sDeviceToken1i\n  var dt1v = sDeviceToken1v\n\n  function completion () {\n    var result = { }\n    result[constants.core.deviceToken1i] = dt1i\n    result[constants.core.deviceToken1v] = dt1v\n\n    return cb(null, result)\n  }\n\n  if (dt1i && dt1v) {\n    return completion()\n  } else {\n    Request.post(constants.endpoints.device.identifier, { }, null, null, function (err, result) {\n      if (err) {\n        debug('_getDeviceTokens error %s', err)\n        return cb(err)\n      } else if (result) {\n        dt1i = result[constants.core.deviceToken1i]\n        dt1v = result[constants.core.deviceToken1v]\n\n        if (dt1i && dt1v) {\n          sDeviceToken1i = dt1i\n          sDeviceToken1v = dt1v\n\n          return completion()\n        }\n      }\n\n      debug('Snapchat._getDeviceTokens parse error %j', result)\n      return cb('Snapchat._getDeviceTokens parse error')\n    })\n  }\n}\n\n/**\n * ptoken value\n * @private\n */\nSnapchat.prototype._getGoogleCloudMessagingIdentifier = function (cb) {\n  var DEFAULT_TOKEN = 'ie'\n\n  process.nextTick(function () {\n    cb(null, DEFAULT_TOKEN)\n  })\n\n  // TODO: cloud messaging identifier always returns 'Error=AUTHENTICATION_FAILED'\n  // skipping this for now to speedup testing\n\n  /*\n  Request.postRaw({\n    url: 'https://android.clients.google.com/c2dm/register3',\n    form: {\n      'X-google.message_id': 'google.rpc1',\n      'device': 4343470343591528399,\n      'sender': 191410808405,\n      'app_ver': 706,\n      'gcm_ver': 7097038,\n      'app': 'com.snapchat.android',\n      'iat': (new Date()).getTime(),\n      'cert': '49f6badb81d89a9e38d65de76f09355071bd67e7'\n    },\n    headers: {\n      'Accept-Language': 'en',\n      'Accept-Locale': 'en_US',\n      'app': 'com.snapchat.android',\n      'Authorization': 'AidLogin 4343470343591528399:5885638743641649694',\n      'Gcm-ver': '7097038',\n      'Accept-Encoding': 'gzip',\n      'User-Agent': 'Android-GCM/1.5 (A116 _Quad KOT49H)'\n    }\n  }, function (err, response, body) {\n    if (err) {\n      return cb(err)\n    } else if (body) {\n      // parse token\n      var token = StringUtils.matchGroup(body, /token=([\\w\\.-]+)/, 1)\n\n      if (token) {\n        return cb(null, token)\n      } else {\n        // debug('_getGoogleCloudMessagingIdentifier using default token %s', body)\n\n        // default token\n        return cb(null, DEFAULT_TOKEN)\n      }\n    }\n\n    debug('_getGoogleCloudMessagingIdentifier parse error %s', body)\n    return cb('_getGoogleCloudMessagingIdentifier error')\n  })*/\n}\n\n/**\n * Attestation, courtesy of casper.io\n * @private\n */\nSnapchat.prototype._getAttestation = function (username, password, ts, cb) {\n  var preHash = StringUtils.getSCPreHashString(username, password, ts, constants.endpoints.account.login)\n  var nonce = StringUtils.sha256HashToBase64(preHash)\n\n  var params = {\n    'nonce': nonce,\n    'authentication': constants.attestation.auth,\n    'apk_digest': constants.attestation.digest(),\n    'timestamp': ts\n  }\n\n  Request.postRaw({\n    url: constants.attestation.URLCasper,\n    form: params\n  }, function (err, response, result) {\n    if (err) {\n      return cb(err)\n    } else if (result && +result.code === 200 && result.attestation) {\n      return cb(null, result.attestation)\n    }\n\n    return cb('Snapchat._getAttestation unknown error')\n  })\n}\n\n/**\n * Client Auth Token, courtesy of casper.io\n *\n * Note that casper.io uses libscplugin.so which has been extracted from the\n * Android Snapchat client.\n *\n * @private\n */\nSnapchat.prototype._getClientAuthToken = function (username, password, ts, cb) {\n  Request.postRaw({\n    url: constants.attestation.URLCasperAuth,\n    form: {\n      username: username,\n      password: password,\n      timestamp: ts\n    }\n  }, function (err, response, result) {\n    if (err) {\n      return cb(err)\n    } else if (result && +result.code === 200 && result.signature) {\n      return cb(null, result.signature)\n    }\n\n    return cb('Snapchat._getClientAuthToken unknown error')\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/lib/constants.js":"var Enum = require('enum')\n\n/**\n * @namespace\n */\nvar constants = module.exports = {\n  // ---------------------------------------------------------------------------\n  // Enums\n  // ---------------------------------------------------------------------------\n\n  /** @enum **/\n  SnapPrivacy: new Enum({\n    'Everyone': 0,\n    'Friends': 1\n  }),\n\n  /** @enum **/\n  StoryPrivacy: new Enum({\n    'Friends': 0,\n    'Everyone': 1,\n    'Custom': 2\n  }),\n\n  /** @enum **/\n  AddSource: new Enum({\n    'Phonebook': 1,\n    'Username': 2,\n    'AddedBack': 3\n  }),\n\n  /** @enum **/\n  MediaKind: new Enum({\n    'Image': 0,\n    'Video': 1,\n    'SilentVideo': 2,\n    'FriendRequest': 3,\n    'StrangerImage': 4,\n    'StrangerVideo': 5,\n    'StrangerSilentVideo': 6\n  }),\n\n  /** @enum **/\n  MessageKind: new Enum({\n    'Text': 0,\n    'Media': 1,\n    'DiscoverShared': 2\n  }),\n\n  /** @enum **/\n  SnapStatus: new Enum({\n    'None': -1,\n    'Sent': 0,\n    'Delivered': 1,\n    'Opened': 2,\n    'Screenshot': 3\n  }),\n\n  /** @enum **/\n  FriendStatus: new Enum({\n    'Confirmed': 0,\n    'Unconfirmed': 1,\n    'Blocked': 2,\n    'Deleted': 3\n  }),\n\n  // ---------------------------------------------------------------------------\n  // Static constants\n  // ---------------------------------------------------------------------------\n\n  screen: {\n    width: 720,\n    height: 1280,\n    maxVideoWidth: 480,\n    maxVideoHeight: 640\n  },\n\n  attestation: {\n    // The user agent specific to making the attestation request.\n    userAgent: 'SafetyNet/7329000 (klte KOT49H); gzip',\n\n    // The sha256 digest of the certificate used to sign the Snapchat APK, base 64 encoded. It should never change.\n    certificateDigest: 'Lxyq/KHtMNC044hj7vq+oOgVcR+kz3m4IlGaglnZWlg=',\n\n    // Google Play Services version used to make the attestation request.\n    GMSVersion: 7329038,\n\n    // Authentication token sent to verify requests with the server to prevent abuse.\n    auth: 'cp4craTcEr82Pdf5j8mwFKyb8FNZbcel',\n\n    // Casper attestation request URL. Special thanks to Liam!\n    URLCasper: 'https://api.casper.io/security/login/attestation',\n\n    // Casper auth URL\n    URLCasperAuth: 'https://api.casper.io/security/login/signrequest',\n\n    // digest values for different versions of snapchat\n    'digest9_8': 'vXCcGhQ7RfL1LUiE3F6vcNORNo7IFSOvuDBunK87mEI=',\n    'digest9_9': 'Yk9Wqmx7TrTatldWI+5PWbQjGA8Gi8ZoO8X9OUAw1hg=',\n    'digest9_10': 'JJShKOLH4YYjWZlJQ71A2dPTcmxbaMboyfo0nsKYayE=',\n    'digest9_11': 'nNsTUhHYJ943NG6vAPNl+tRr1vktNb9HpvRxZuu/rrE=',\n    'digest9_12_0_1': 'W4snbl56it9XbT2lsL4gyHwMsElnmOPBDp+iIYqbGcI=',\n    'digest9_12_1': 'fGZExseKdFH1bltkKloaAGfGx0vnKDDymKiJAiLo3dU=',\n    'digest9_12_2': 'LMQNajaQ4SO7vNaQS1FRokxCtQXeIHwKZiJYhMczDGk=',\n    'digest9_12_3': 'bnVK+fT6BdldrY279ShOR9QZx0OIRJxGoPslBn70vng=',\n    'digest9_13': 'BWDe2a5b3I26Yw6z4Prvh2aEMRcf2B1FMs8136QIeCM=',\n    'digest9_14': 'k6IftsTIpJeVhZDoHZv9zxDhE7HuN50PpO3O/zIXxsU=',\n    'digest9_14_1': 'pS+fbZ4Xw0ThusoWRo2eCldGmHohNYvau/VULlJbBnQ=',\n    'digest9_14_2': '5O40Rllov9V8PpwD5zPmmp+GQi7UMIWz2A0LWZA7UX0=',\n\n    // returns the digest for the current version of the snapchat client\n    digest: function () {\n      // var value = constants.attestation['digest9_14']\n      var value = constants.attestation['digest9_14_2']\n      if (!value) throw new Error('constants.attestation.digest invalid value')\n\n      return value\n    },\n\n    // Authentication token sent to verify requests with the server to prevent abuse.\n    'droidGuard': 'CgbMYHoVNWLYAQE4YRoMCMKa2IIDEKC349kCqgERCLikhu8CEKL-jf34_____wHoAfLYvrb7_____wHoAbjLt877_____wE4azhLEokMuKToh_JDOAH8CvNUrmmbUkT045BmT6P_KNQSwOPtKxfJzK43U0I8A3x9lhvIbj5rbW3EREoNXLsI4okM7eonVUPt_PNYSK-b3U-T_bCfQkhKZ6hQ2ByXyi81LMp9IbzCho9KzRi_3zn9ffewSW2UjaGj71_gm4iapZXcQCigaWJ28VW10g8aeVcXVnXMg7UfDfx7NXghb0ZtlNXu8QxSCTWzUrW5nQH_TcYVKKhO4uFkX_sPr9MVwchg5oUSfvAZ2X2ZnsrkszrUr_NtlLS3w56DnPJvcOnN7X0N70p5Hj8Uqlx-a39c6BO4zfd_TAsqiV02zLoVctaht332OHA8Ejh1tIs89d0xKryMBq3OUSKKfLuMcfohU9gLuYF5_yfh3LGt2A4KSlUF1_DKcgxhiBV-QlNJWOL45fXjPl1_h7KcxfegJy19tpZ8cZ_KAWd4W00NJb5AmSGnzIB0iAkh0iC6fwpxngWS9ew_1gQC68wHrxZ8oBsLjZyzWk1eV69Xt3FSsTRzhpaIgnveaEtRZt6KsZUy2sCgzU1BvBF-Cm9kW1taPLvhURVxljUABxyKSsEmCFkyJbKDqz6bnTmAEXoJVJ3OW0OW9bpLX7IsKSlnIKOAnET0aH0e7CLkpj2nke8h8nv5PoW-s60Cc_5SirP4hTZRJDvXJecYljQcTTX6MOKx-gRiLdvc0NWzow8yrGTuCqQ0rYBEUELh8U7dGYQk6WX92aJEWa6uZb3AN9WFGg0GxiY1Bpq9kO58mHSBqeJXCrQ4mq2GJJxhxUE13zzbqsWyPi66MbTH1-YRTrjVPj5nkZqomuCtWIyWnC573IyG37lt8eYLXLNTbwuVDmUfaXytgntNExITdf9iiN2zFEYAlKSEROMc3FEKwApy9zzeTC9ItHsXGm63vv9s_2zaKEk4kUP3ozNfIMYeImk2piUs5OhEzpdAx_xyHbQICac2IA5arJ0_kqZ42tcuIjnzw8IJuU4xTDfEK12Ju7HaK8KA2i8v5Wtv28EQdqUUXByM39t_u16yI2y_Me545HGO18r-GCH3XJPe1GqwMq_J8vJSx3ecZhEXWBOZsyW5OvZ4YjHULRBDphZpyOmVsW7pLUprr42cU1BtitQy0aJm-qzd1ud4FspjRf-bsuRvWruqdqPTG80NbB-WUPCDNTSZ49bwQ9_CW0VQbqzDRupyG-xl16DwCWvqeWVd-v2DYTKCESsKfJhUHmYyK_GbTgsEioZIKmgN6UERMYLxKRRibkT8r0vWpsqx53xB_MenVzfOmpsOCJt5ITalsMVINUnuYekYw1YG9b6HRLtR4dSZj36j6gMDwGpOEPtHeEt6Fjym0SjMNA6kL2qp8rqxSiKrc37RE7Y6f6d2RlarGZG5woPl59F4onBR3Z1SR5mc9Srzrsezn6petEl19w0GtPocw5mrbYphgmjqGKNKqgLCKQ5yhfA1FQMkaZQQSJRd_zg5DuKUr7Bi_fc0ag-iJ1YqCrSiR-AmZV2DUGcNuYe9BOKt70GpfYfyc2DIcSA6oNNnRyi5uqjA7FUvggsWh80s-1yHSl4klFmQN0X10X-FszbmP2PYOlipbG6lNe2qCdlT49XgO17625Spfu7ehpeP-wRjWxgG5A-l7HabM3BrJRvYiW4YXWmloH2C8qOiqnHtC_mDjWAChSK9unVfMLQOeHiBInGR3s44wZvgtVzn_uSHuIacbqCr8VW-efmRVJ5m3iNado9smCCn74xnkMFR4_nRTCz-uwTsQp6Vvk7A6B-avGIkSBWK26nn7p0wB-btIYVZhbHlvs7eRL4PF5sc7gDgS6fpTVOVTCUEUYDfOeyu2TD-JUv0tnNxyH8zdeMHYjtQKgHDNMoWHlA1ly_1BqbU2urn3N07I4BuoBWhSfzcsRmOXtBtylCrVRhC9MEOR-I8QGgFByZfixG4XwGQnbCx-LyAtn6ngcii79W0pA8AoG_-a0s-3aIebEpcz2_qPXqxZ1qk4ByA10VjIBTC73vY1_ChkHg6bvmOsgYcrOFmD9nrbBCgapBGOx_yWsPLLwAD-cGj'\n  },\n\n  core: {\n    // The API URL. iOS uses the /bq endpoint, Android clients use the /ph endpoint.\n    baseURL: 'https://feelinsonice-hrd.appspot.com',\n\n    // A set of possible API proxies\n    baseList: [\n      'https://feelinsonice-hrd.appspot.com',\n      'https://app.snapchat.com'\n    ],\n\n    // Before updating this value, confirm that the library requests everything in the same way as the app.\n    // Snapchat/9.10.0.0 (HTC One; Android 4.4.2#302626.7#19; gzip)'\n    // userAgent: 'Snapchat/9.12.2.0 (SM-N9005; Android 5.0.2; gzip)',\n    // userAgent: 'Snapchat/9.14.0.0 (SM-N9005; Android 5.0.2; gzip)',\n    userAgent: 'Snapchat/9.14.2.0 (SM-N9005; Android 5.0.2; gzip)',\n\n    // An alternate base URL for sending certain POST requests.\n    eventsURL: 'https://sc-analytics.appspot.com/post_events',\n\n    // The base URL for sending analytics.\n    analyticsURL: 'https://sc-analytics.appspot.com/analytics/bz',\n\n    // The API secret used to create access tokens.\n    secret: 'iEk21fuwZApXlz93750dmW22pw389dPwOk',\n\n    // Used when no session is available.\n    staticToken: 'm198sOkJEn37DjqZ32lpRu76xmw288xSQ9',\n\n    // Used to encrypt and decrypt media.\n    blobEncryptionKey: 'M02cnQ51Ji97vwT4',\n\n    // Used to create the token for each request.\n    hashPattern: '0001110111101110001111010101111011010001001110011000110001000110',\n\n    // Used to separate form fields when sending snaps.\n    boundary: 'Boundary+0xAbCdEfGbOuNdArY',\n\n    deviceToken1i: 'dtoken1i',\n    deviceToken1v: 'dtoken1v',\n\n    googleDefaultPublicKey: 'AAAAgMom/1a/v0lblO2Ubrt60J2gcuXSljGFQXgcyZWveWLEwo6prwgi3iJIZdodyhKZQrNWp5nKJ3srRXcUW+F1BD3baEVGcmEgqaLZUNBjm057pKRI16kB0YppeGx5qIQ5QjKzsR8ETQbKLNWgRY0QRNVz34kMJR3P/LgHax/6rmf5AAAAAwEAAQ=='\n  },\n\n  headers: {\n    timestamp: 'X-Timestamp',\n    userAgent: 'User-Agent',\n    contentType: 'Content-Type',\n    acceptLanguage: 'Accept-Language',\n    acceptLocale: 'Accept-Locale',\n    clientAuth: 'X-Snapchat-Client-Auth',\n    clientAuthToken: 'X-Snapchat-Client-Auth-Token',\n    values: {\n      language: 'en',\n      locale: 'en_US'\n    }\n  },\n\n  featureSettings: {\n    frontFacingFlash: 'front_facing_flash',\n    replaySnaps: 'replay_snaps',\n    smartFilters: 'smart_filters',\n    visualFilters: 'visual_filters',\n    powerSaveMode: 'power_save_mode',\n    specialText: 'special_text',\n    swipeCashMode: 'swipe_cash_mode',\n    travelMode: 'travel_mode'\n  },\n\n  endpoints: {\n    misc: {\n      ping: '/loq/ping',\n      locationData: '/loq/loc_data',\n      serverList: '/loq/gae_server_list',\n      doublePost: '/loq/double_post',\n      reauth: '/bq/reauth',\n      suggestFriend: '/bq/suggest_friend'\n    },\n\n    update: {\n      all: '/loq/all_updates',\n      snaps: '/bq/update_snaps',\n      stories: '/bq/update_stories',\n      user: '/loq/update_user', // just /update_stories?\n      featureSettings: '/bq/update_feature_settings'\n    },\n\n    account: {\n      login: '/loq/login',\n      logout: '/ph/logout',\n      twoFAPhoneVerify: '/loq/two_fa_phone_verify',\n      twoFARecoveryCode: '/loq/two_fa_recovery_code',\n      setBestsCount: '/bq/set_num_best_friends',\n      settings: '/ph/settings',\n      snaptag: '/bq/snaptag_download',\n      registration: {\n        start: '/loq/register',\n        username: '/loq/register_username',\n        getCaptcha: '/bq/get_captcha',\n        solveCaptcha: '/bq/solve_captcha',\n        verifyPhone: '/bq/phone_verify',\n        suggestUsername: '/bq/suggest_username'\n      },\n      avatar: {\n        set: '/bq/upload_profile_data',\n        get: '/bq/delete_profile_data',\n        remove: '/bq/delete_profile_data',\n        getFriend: '/bq/download_friends_profile_data'\n      }\n    },\n\n    chat: {\n      sendMessage: '/loq/conversation_post_messages',\n      conversation: '/loq/conversation',\n      conversations: '/loq/conversations',\n      authToken: '/loq/conversation_auth_token',\n      clear: '/ph/clear',\n      clearFeed: '/loq/clear_feed',\n      clearConvo: '/loq/clear_conversation',\n      typing: '/bq/chat_typing',\n      media: '/bq/chat_media',\n      uploadMedia: '/bq/upload_chat_media',\n      shareMedia: '/loq/conversation_share_media'\n    },\n\n    device: {\n      IPRouting: '/bq/ip_routing',\n      IPRoutingError: '/bq/ip_routing_error',\n      identifier: '/loq/device_id',\n      device: '/ph/device'\n    },\n\n    discover: {\n      channels: '/discover/channel_list?region=',\n      icons: '/discover/icons?icon=',\n      snaps: '/discover/dsnaps?edition_id=', // &snap_id= &hash= &publisher= &session.resourceParamName=session.resourceParamValue\n      intros: '/discover/intro_videos?publisher=' // &intro_video= &session.resourceParamName=session.resourceParamValue\n    },\n\n    friends: {\n      find: '/bq/find_friends',\n      findNearby: '/bq/find_nearby_friends',\n      bests: '/bq/bests',\n      friend: '/bq/friend',\n      hide: '/loq/friend_hide',\n      search: '/loq/friend_search',\n      exists: '/bq/user_exists'\n    },\n\n    snaps: {\n      loadBlob: '/bq/blob', // /ph/blob ?\n      upload: '/ph/upload',\n      send: '/loq/retry',\n      retry: '/loq/send'\n    },\n\n    stories: {\n      stories: '/bq/stories',\n      upload: '/ph/upload',\n      blob: '/bq/story_blob?story_id=',\n      thumb: '/bq/story_thumbnail?story_id=',\n      authBlob: '/bq/auth_story_blob?story_id=',\n      authThumb: '/bq/auth_story_thumbnail?story_id=',\n      remove: '/bq/delete_story',\n      post: '/bq/post_story',\n      retryPost: '/bq/retry_post_story'\n    },\n\n    cash: {\n      checkRecipientEligibility: '/cash/check_recipient_eligible',\n      generateAccessToken: '/cash/generate_access_token',\n      generateSignature: '/cash/generate_signature_for_phone',\n      markViewed: '/cash/mark_as_viewed',\n      resetAccount: '/cash/reset_account',\n      transaction: '/cash/transaction',\n      updateTransaction: '/cash/update_transaction',\n      validateTransaction: '/cash/validate_transaction'\n    },\n\n    android: {\n      findNearbyFriends: '/bq/and/find_nearby_friends',\n      changeEmail: '/loq/and/change_email',\n      changePass: '/loq/and/change_password',\n      getPassStrength: '/loq/and/get_password_strength',\n      registerExp: '/loq/and/register_exp'\n    },\n\n    sharedDescription: '/shared/description'\n  },\n\n  // ---------------------------------------------------------------------------\n  // Dynamic Constants\n  // ---------------------------------------------------------------------------\n\n  addSourceFromString: function (addSource) {\n    if (addSource === 'ADDED_BY_PHONE') {\n      return constants.AddSource.Phonebook.value\n    } else if (addSource === 'ADDED_BY_USERNAME') {\n      return constants.AddSource.Username.value\n    } else if (addSource === 'ADDED_BY_ADDED_ME_BACK') {\n      return constants.AddSource.AddedBack.value\n    }\n\n    return 0\n  },\n\n  stringFromAddSource: function (addSource) {\n    if (addSource === constants.AddSource.Phonebook.value) {\n      return 'ADDED_BY_PHONE'\n    } else if (addSource === constants.AddSource.Username.value) {\n      return 'ADDED_BY_USERNAME'\n    } else if (addSource === constants.AddSource.AddedBack.value) {\n      return 'ADDED_BY_ADDED_ME_BACK'\n    }\n\n    return null\n  },\n\n  stringFromMediaKind: function (mediaKind) {\n    return constants.MediaKind.get(mediaKind).key\n  },\n\n  stringFromStoryPrivacy: function (storyPrivacy) {\n    if (storyPrivacy === constants.StoryPrivacy.Everyone.value) {\n      return 'EVERYONE'\n    } else if (storyPrivacy === constants.StoryPrivacy.Friends.value) {\n      return 'FRIENDS'\n    } else if (storyPrivacy === constants.StoryPrivacy.Custom.value) {\n      return 'CUSTOM'\n    }\n\n    return null\n  },\n\n  messageKindFromString: function (messageKind) {\n    messageKind = (messageKind || '').toLowerCase()\n\n    if (messageKind === constants.MessageKind.Text.key.toLowerCase()) {\n      return constants.MessageKind.Text.value\n    } else if (messageKind === constants.MessageKind.Media.key.toLowerCase()) {\n      return constants.MessageKind.Media.value\n    } else if (messageKind === constants.MessageKind.DiscoverShared.key.toLowerCase()) {\n      return constants.MessageKind.DiscoverShared.value\n    }\n\n    return null\n  },\n\n  mediaKindIsImage: function (mediaKind) {\n    return mediaKind === constants.MediaKind.Image.value ||\n           mediaKind === constants.MediaKind.StrangerImage.value\n  },\n\n  mediaKindIsVideo: function (mediaKind) {\n    return mediaKind === constants.MediaKind.Video.value ||\n           mediaKind === constants.MediaKind.SilentVideo.value ||\n           mediaKind === constants.MediaKind.StrangerVideo.value ||\n           mediaKind === constants.MediaKind.StrangerSilentVideo.value\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/lib/request.js":"module.exports = Request\n\nvar debug = require('debug')('snapchat:request')\nvar https = require('https')\nvar request = require('request')\nvar urljoin = require('url-join')\nvar extend = require('xtend')\nvar zlib = require('zlib')\nvar iconv = require('iconv-lite')\n\nvar BufferUtils = require('./buffer-utils')\nvar StringUtils = require('./string-utils')\nvar constants = require('./constants')\n\n/**\n * Snapchat wrapper for HTTP requests\n *\n * @class\n * @param {Object} opts\n */\nfunction Request (opts) {\n  var self = this\n  if (!(self instanceof Request)) return new Request(opts)\n  if (!opts) opts = {}\n\n  self.HTTPMethod = opts.method\n  self.HTTPHeaders = {}\n  self.opts = opts\n\n  if (opts.method === 'POST') {\n    if (opts.endpoint) {\n      self._initPOST(opts)\n    } else if (opts.url) {\n      self._initPOSTURL(opts)\n    } else {\n      throw new Error('invalid request')\n    }\n  } else if (opts.method === 'GET') {\n    self._initGET(opts)\n  } else {\n    throw new Error('invalid request')\n  }\n}\n\nRequest.prototype._initHeaderFields = function (headers) {\n  var self = this\n\n  self.HTTPHeaders[constants.headers.contentType] = 'application/x-www-form-urlencoded'\n  self.HTTPHeaders[constants.headers.userAgent] = constants.core.userAgent\n  self.HTTPHeaders[constants.headers.acceptLanguage] = constants.headers.values.language\n  self.HTTPHeaders[constants.headers.acceptLocale] = constants.headers.values.locale\n\n  if (headers) {\n    self.HTTPHeaders = extend(self.HTTPHeaders, headers)\n  }\n}\n\n/**\n * Automatically adds query parameters:\n * - timestamp\n * - req_token\n * Automatically adds HTTP header fields:\n * - User-Agent\n * - Accept-Language\n * - Accept-Locale\n * - Content-Type\n */\nRequest.prototype._initPOST = function (opts) {\n  var self = this\n\n  Request._applyHeaderOverrides(opts)\n  opts.token = opts.token || constants.core.staticToken\n\n  self._initHeaderFields(opts.headers)\n  Request._applyOverrides(opts)\n\n  self.URL = urljoin(constants.core.baseURL, opts.endpoint)\n\n  if (!opts.timestamp) {\n    opts.timestamp = StringUtils.timestamp()\n  }\n\n  var reqToken = 'req_token'\n  if (!opts.params[reqToken]) {\n    opts.params[reqToken] = StringUtils.hashSCString(opts.token, opts.timestamp)\n  }\n\n  if (!opts.params.timestamp) {\n    opts.params.timestamp = +opts.timestamp\n  }\n\n  // special-case for uploading snaps\n  if (opts.endpoint === constants.endpoints.snaps.upload) {\n    var body = [ ]\n\n    for (var key in opts.params) {\n      if (key === 'data') {\n        body.push(BufferUtils.boundaryForBuffer(key, opts.params[key]))\n      } else {\n        body.push(BufferUtils.boundaryForString(key, opts.params[key]))\n      }\n    }\n\n    // final boundary\n    body.push(new Buffer('\\r\\n--' + constants.core.boundary + '--\\r\\n'))\n\n    // concat all buffers together to form the body\n    self.HTTPBody = Buffer.concat(body)\n    self.multipart = true\n\n    // debugging...\n    // var fs = require('fs')\n    // fs.writeFileSync('out.txt', self.HTTPBody.toString('utf-8'))\n    // console.log(self.HTTPBody.toString('utf-8'))\n  } else {\n    self.HTTPBody = opts.params\n  }\n\n  if (opts.endpoint === constants.endpoints.snaps.loadBlob || opts.endpoint === constants.endpoints.chat.media) {\n    self.HTTPHeaders[constants.headers.timestamp] = opts.timestamp\n  }\n}\n\nRequest.prototype._initPOSTURL = function (opts) {\n  var self = this\n\n  self.URL = opts.url\n  self.HTTPBody = opts.eventData\n}\n\n/**\n * Automatically adds HTTP header fields:\n * - User-Agent\n * - Accept-Language\n * - Accept-Locale\n * - Content-Type\n */\nRequest.prototype._initGET = function (opts) {\n  var self = this\n\n  Request._applyHeaderOverrides(opts)\n  self._initHeaderFields(opts.headers)\n\n  self.URL = urljoin(constants.core.baseURL, opts.endpoint)\n}\n\n/**\n * Initiates the underlying HTTP request Request.httpRequest.\n *\n * @param {function} cb\n */\nRequest.prototype.start = function (cb) {\n  var self = this\n\n  function wrapcb (err, response, body) {\n    var contentType = response && response.headers && response.headers['content-type']\n    if (contentType && contentType !== 'application/octet-stream') {\n      response.body = iconv.decode(response.body, 'utf8')\n    }\n    if (err) {\n      return cb(err, body)\n    } else if (!err && response && (response.statusCode < 200 || response.statusCode >= 300)) {\n      // catch snapchat API error codes\n      debug('Snapchat Request Error: %d (%s) \\nendpoint: %s \\nheaders: %j \\nrequest: %s',\n            response.statusCode,\n            response.statusMessage,\n            self.opts.endpoint,\n            response.request.headers,\n            self.multipart ? '' : response.request.body.toString('utf-8').substr(0, 80))\n\n      // console.log(response)\n      // console.log(response.request.body.toString('base64'))\n      // console.log(response.request.body.toString('utf-8'))\n\n      return cb('Snapchat API error ' + response.statusCode + ' (' + response.statusMessage + ')', body)\n    } else {\n      var result = body\n\n      // attempt to parse the body as JSON if appropriate\n      if (contentType && contentType.indexOf('application/json') >= 0) {\n        result = StringUtils.tryParseJSON(body)\n\n        if (!result) {\n          debug('Snapchat Request JSON Parse Error: \\nresponse: \"%s\"', body)\n          // return cb('JSON parse error', body)\n        }\n      }\n\n      return cb(null, result)\n    }\n  }\n\n  if (self.HTTPMethod === 'POST') {\n    if (self.multipart) {\n      self.HTTPHeaders['content-length'] = Buffer.byteLength(self.HTTPBody)\n\n      // self.HTTPHeaders['X-Timestamp'] = 0\n\n      // TODO:\n      // neither objc or php versions send Content-Length header\n      // don't think we can use request because its multipart/form-data uses random boundary\n\n      var req = https.request({\n        host: constants.core.baseURL.replace(/http?s:\\/\\//, ''),\n        path: self.endpoint,\n        method: 'POST',\n        headers: self.HTTPHeaders,\n        agent: false,\n        rejectUnauthorized: false\n        //, secureOptions: require('constants').SSL_OP_NO_TLSv1\n      }, function (response) {\n        response.request = req\n        response.request.headers = req._headers\n\n        console.log('status', response.statusCode)\n        console.log('headers', JSON.stringify(response.headers))\n\n        var result = []\n        response.on('data', function (chunk) {\n          console.log('RESPONSE DATA', chunk)\n          result.push(chunk)\n        })\n\n        response.on('end', function () {\n          console.log('RESPONSE END')\n          response.body = Buffer.concat(result)\n          wrapcb(null, response, response.body)\n        })\n      })\n\n      // req.removeHeader('content-length')\n      // req.removeHeader('transfer-encoding')\n      // req.removeHeader('connection')\n\n      req.on('error', function (err) {\n        console.error('ERROR', err)\n        wrapcb(err, null, null)\n      })\n\n      req.on('abort', function () {\n        console.error('ABORT')\n        wrapcb('abort', null, null)\n      })\n\n      req.write(self.HTTPBody)\n      req.end()\n      console.log('REQUEST END', req._headers)\n    } else {\n      self.httpRequest = request.post({\n        url: self.URL,\n        headers: self.HTTPHeaders,\n        form: self.HTTPBody,\n        encoding: null\n      }, wrapcb)\n\n      // debug('%s Request %s (headers %j) (body \\'%s\\')', self.HTTPMethod, self.URL, self.HTTPHeaders,\n      //       self.httpRequest.body.toString('utf-8'))\n    }\n  } else {\n\n    self.httpRequest = request({\n      url: self.URL,\n      headers: self.HTTPHeaders,\n      encoding: null\n    }, wrapcb)\n\n    debug('%s Request %s (headers %j)', self.HTTPMethod, self.URL, self.HTTPHeaders)\n  }\n}\n\n// -----------------------------------------------------------------------------\n// static utility methods\n// -----------------------------------------------------------------------------\n\n/**\n * @static\n * @param {string=} endpoint Optional endpoint of the request relative to the base URL.\n * @param {Object=} params Optional parameters for the request.\n * @param {string=} gauth Optional parameter set to the X-Snapchat-Client-Auth-Token header field.\n * @param {string=} token Optional snapchat auth token returned from logging in.\n * @param {Object=} opts Optional custom options.\n * @param {function} cb\n * @return {Request} new Request wrapping this HTTP POST request.\n */\nRequest.post = function (endpoint, params, gauth, token, opts, cb) {\n  // handle optional parameters\n  if (typeof params === 'function') {\n    cb = params\n    params = { }\n    gauth = token = opts = null\n  } else if (typeof gauth === 'function') {\n    cb = gauth\n    gauth = token = opts = null\n  } else if (typeof token === 'function') {\n    cb = token\n    token = opts = null\n  } else if (typeof opts === 'function') {\n    cb = opts\n    opts = null\n  }\n\n  var headers = { }\n  headers[constants.headers.clientAuthToken] = 'Bearer ' + (gauth || '')\n\n  return Request.postCustom(endpoint, params, headers, token, opts, cb)\n}\n\n/**\n * @static\n * @param {string} endpoint endpoint of the request relative to the base URL.\n * @param {Object} params parameters for the request.\n * @param {Object} headers Custom HTTP headers for this request.\n * @param {string} token snapchat auth token returned from logging in.\n * @param {Object=} opts Optional custom options.\n * @param {function} cb\n * @return {Request} new Request wrapping this HTTP POST request.\n */\nRequest.postCustom = function (endpoint, params, headers, token, opts, cb) {\n  // handle optional parameters\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = null\n  }\n\n  opts = opts || { }\n\n  var request = new Request(extend({\n    method: 'POST',\n    endpoint: endpoint,\n    token: token,\n    params: params,\n    headers: headers\n  }, opts))\n\n  request.start(cb)\n  return request\n}\n\n/**\n * @static\n * @param {string} endpoint The endpoint of the request relative to the base URL.\n * @param {function} cb\n * @return {Request} new Request wrapping this HTTP GET request\n */\nRequest.get = function (endpoint, cb) {\n  var request = new Request({\n    method: 'GET',\n    endpoint: endpoint\n  })\n\n  request.start(cb)\n  return request\n}\n\n/**\n * @static\n * @param {Object} eventData\n * @param {function} cb\n * @return {Request} new Request wrapping this events HTTP POST request\n */\nRequest.sendEvents = function (eventData, cb) {\n  var request = new Request({\n    method: 'POST',\n    url: constants.core.eventsURL,\n    eventData: eventData\n  })\n\n  request.start(cb)\n  return request\n}\n\nRequest.postRaw = function (params, cb) {\n  request.post(extend(params, {\n    encoding: null\n  }), function (err, response, body) {\n    if (err) {\n      return cb(err, response, body)\n    }\n\n    var contentType = response.headers['content-type']\n    var encoding = response.headers['content-encoding']\n\n    function contentTypeWrapper (err, body) {\n      if (err) {\n        return cb(err, response, body)\n      } else if (contentType.indexOf('application/json') >= 0) {\n        return cb(err, response, StringUtils.tryParseJSON(body.toString()))\n      } else if (contentType.indexOf('text/plain') >= 0) {\n        return cb(err, response, body.toString())\n      } else {\n        return cb(err, response, body)\n      }\n    }\n\n    if (encoding === 'gzip') {\n      zlib.gunzip(body, function (err, dezipped) {\n        contentTypeWrapper(err, dezipped && dezipped.toString())\n      })\n    } else if (encoding === 'deflate') {\n      zlib.inflate(body, function (err, decoded) {\n        contentTypeWrapper(err, decoded && decoded.toString())\n      })\n    } else {\n      contentTypeWrapper(err, body)\n    }\n  })\n}\n\n// -----------------------------------------------------------------------------\n// override handling\n// -----------------------------------------------------------------------------\n\nRequest.overrideHeaderValuesGlobally = function (headers) {\n  globalHeaderOverrides = headers\n}\n\nRequest.overrideHeaderValues = function (headers, endpoint) {\n  scopeHeaderOverrides[endpoint] = headers\n}\n\nRequest.overrideValues = function (params, endpoint) {\n  scopeParamOverrides[endpoint] = params\n}\n\nRequest.overrideValuesGlobally = function (params) {\n  globalParamOverrides = params\n}\n\nRequest.overrideEndpoints = function (endpoints) {\n  endpointOverrides = endpoints\n}\n\nRequest._applyOverrides = function (opts) {\n  if (opts.params) {\n    opts.params = extend(opts.params, globalParamOverrides)\n    opts.params = extend(opts.params, scopeParamOverrides[opts.endpoint] || { })\n  }\n\n  if (opts.endpoint) {\n    opts.endpoint = endpointOverrides[opts.endpoint] || opts.endpoint\n  }\n}\n\nRequest._applyHeaderOverrides = function (opts) {\n  if (!opts.headers) return\n\n  opts.headers = extend(opts.headers, globalHeaderOverrides)\n  opts.headers = extend(opts.headers, scopeHeaderOverrides[opts.endpoint] || { })\n}\n\nvar globalHeaderOverrides = { }\nvar globalParamOverrides = { }\nvar scopeParamOverrides = { }\nvar scopeHeaderOverrides = { }\nvar endpointOverrides = { }\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/lib/buffer-utils.js":"module.exports = BufferUtils\n\nvar crypto = require('crypto')\nvar constants = require('./constants')\n\n/**\n * @namespace\n * @static\n */\nfunction BufferUtils () {\n  // static class\n}\n\n/**\n * @param {Buffer} data\n * @return {boolean}\n */\nBufferUtils.isJPEG = function (data) {\n  var h = BufferUtils._getHeader(data)\n\n  return h && h.a === 0xFF && h.b === 0xD8 && h.c === 0xFF\n}\n\n/**\n * @param {Buffer} data\n * @return {boolean}\n */\nBufferUtils.isPNG = function (data) {\n  var h = BufferUtils._getHeader(data)\n\n  return h && h.a === 0x89 && h.b === 0x50 && h.c === 0x4E && h.d === 0x47\n}\n\n/**\n * @param {Buffer} data\n * @return {boolean}\n */\nBufferUtils.isImage = function (data) {\n  return BufferUtils.isJPEG(data) || BufferUtils.isPNG(data)\n}\n\n/**\n * @param {Buffer} data\n * @return {boolean}\n */\nBufferUtils.isMPEG4 = function (data) {\n  var h = BufferUtils._getHeader(data, 4)\n\n  // return h && h.a === 0x00 && h.b === 0x00 && h.c === 0x00\n  return h && h.a === 0x66 && h.b === 0x74 && h.c === 0x79 && h.d === 0x70\n}\n\n/**\n * @param {Buffer} data\n * @return {boolean}\n */\nBufferUtils.isMedia = function (data) {\n  return BufferUtils.isImage(data) || BufferUtils.isMPEG4(data)\n}\n\n/**\n * @param {Buffer} data\n * @return {boolean}\n */\nBufferUtils.isCompressed = function (data) {\n  var h = BufferUtils._getHeader(data)\n\n  // check for presence of a PK header\n  return h && h.a === 0x50 && h.b === 0x4B\n  // && h.c === 0x03 && h.d === 0x04\n}\n\n/**\n * @param {Buffer} data\n * @return {Object}\n */\nBufferUtils._getHeader = function (data, index) {\n  index = index || 0\n\n  if (!data || data.length < index + 4) {\n    return null\n  } else {\n    return {\n      a: data.readUInt8(index + 0),\n      b: data.readUInt8(index + 1),\n      c: data.readUInt8(index + 2),\n      d: data.readUInt8(index + 3)\n    }\n  }\n}\n\n/**\n * @param {Buffer} data\n * @return {string}\n */\nBufferUtils.getFileExtension = function (data) {\n  if (BufferUtils.isJPEG(data)) return '.jpg'\n  if (BufferUtils.isPNG(data)) return '.png'\n  if (BufferUtils.isMPEG4(data)) return '.mp4'\n  if (BufferUtils.isCompressed(data)) return '.zip'\n  return '.dat'\n}\n\n/**\n * @param {Buffer} data\n * @return {string}\n */\nBufferUtils.sha256HashToBase64 = function (data) {\n  return crypto.createHash('sha256').update(data).digest('base64')\n}\n\n/**\n * @param {Buffer} data\n * @return {string}\n */\nBufferUtils.sha256HashToHex = function (data) {\n  return crypto.createHash('sha256').update(data).digest('hex')\n}\n\n/**\n * @param {Buffer} a\n * @param {Buffer} b\n * @return {string}\n */\nBufferUtils.hashSC = function (a, b) {\n  var secret = new Buffer(constants.core.secret)\n\n  var firstData = Buffer.concat([ secret, a ])\n  var secondData = Buffer.concat([ b, secret ])\n\n  var first = BufferUtils.sha256HashToHex(firstData)\n  var second = BufferUtils.sha256HashToHex(secondData)\n\n  var pattern = constants.core.hashPattern\n  var hash = ''\n\n  for (var i = 0; i < pattern.length; ++i) {\n    if (pattern.charAt(i) === '0') {\n      hash += first.charAt(i)\n    } else {\n      hash += second.charAt(i)\n    }\n  }\n\n  return hash\n}\n\n/**\n * Decrypts Buffer data for stories.\n *\n * @param {Buffer} data\n * @param {string} key (base64)\n * @param {string} iv (base64)\n * @return {Buffer}\n */\nBufferUtils.decryptStory = function (data, key, iv) {\n  if (!data || !key || !iv) throw new Error('BufferUtils.decryptStory invalid params')\n\n  var keyBuffer = new Buffer(key, 'base64')\n  var ivBuffer = new Buffer(iv, 'base64')\n\n  return BufferUtils.AES128DecryptedData(data, keyBuffer, ivBuffer)\n}\n\n/**\n * Decrypts Buffer data for stories.\n *\n * @param {Buffer} data\n * @param {Buffer} key\n * @param {Buffer} iv\n * @return {Buffer}\n */\nBufferUtils.AES128DecryptedData = function (data, key, iv) {\n  var keyLength = (key.length >= 32 ? 32 : 16)\n  var algorithm = (keyLength === 32 ? 'aes-256-cbc' : 'aes-128-cbc')\n  var decipher = crypto.createDecipheriv(algorithm, key.slice(0, keyLength), iv.slice(0, 16))\n\n  return Buffer.concat([\n    decipher.update(data),\n    decipher.final()\n  ])\n}\n\n/**\n * Generates a HTTP multipart/form-data boundary for the given key key,value pair.\n *\n * @param {string} key\n * @param {string} value\n * @return {Buffer}\n */\nBufferUtils.boundaryForString = function (key, value) {\n  return Buffer.concat([\n    new Buffer('\\r\\n--' + constants.core.boundary + '\\r\\n'),\n    new Buffer('Content-Disposition: form-data; name=\"' + key + '\"\\r\\n\\r\\n'),\n    new Buffer('' + value)\n  ])\n}\n\n/**\n * Generates a HTTP multipart/form-data boundary for the given key key,value pair.\n *\n * @param {string} key\n * @param {Buffer} value\n * @return {Buffer}\n */\nBufferUtils.boundaryForBuffer = function (key, value) {\n  BufferUtils.assertBuffer(value)\n\n  return Buffer.concat([\n    new Buffer('\\r\\n--' + constants.core.boundary + '\\r\\n'),\n    new Buffer('Content-Disposition: form-data; name=\"' + key + '\"; filename=\"' + key + '\"\\r\\n'),\n    new Buffer('Content-Type: application/octet-stream\\r\\n\\r\\n'),\n    value\n  ])\n}\n\nBufferUtils.assertBuffer = function (data) {\n  if (!Buffer.isBuffer(data)) {\n    throw new Error('invalid Buffer', data)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/lib/string-utils.js":"module.exports = StringUtils\n\nvar crypto = require('crypto')\nvar uuid = require('node-uuid')\nvar constants = require('./constants')\nvar bignum = require('bignum')\nvar ursa = require('ursa')\nvar NodeRSA = require('node-rsa')\nvar BufferUtils = require('./buffer-utils')\n\n/**\n * @namespace\n * @static\n */\nfunction StringUtils () {\n  // static class\n}\n\n/**\n * @return {string} milliseconds for current time from epoch as a string\n */\nStringUtils.timestamp = function () {\n  return StringUtils.timestampFrom(new Date())\n}\n\n/**\n * @param {Date} date\n * @return {string} milliseconds date is from epoch as a string\n */\nStringUtils.timestampFrom = function (date) {\n  return '' + date.getTime()\n}\n\n/**\n * @param {string} str\n * @param {string} key\n * @return {string}\n */\nStringUtils.hashHMacToBase64 = function (str, key) {\n  return crypto.createHmac('sha256', key).update(str).digest('base64')\n}\n\n/**\n * @param {string} str\n * @return {string}\n */\nStringUtils.md5HashToHex = function (str) {\n  return crypto.createHash('md5').update(str).digest('hex')\n}\n\n/**\n * @param {string} str\n * @return {string}\n */\nStringUtils.sha256HashToBase64 = function (str) {\n  return crypto.createHash('sha256').update(str).digest('base64')\n}\n\n/**\n * @param {string} str\n * @return {string}\n */\nStringUtils.sha256HashToHex = function (str) {\n  return crypto.createHash('sha256').update(str).digest('hex')\n}\n\n/**\n * @param {string} first\n * @param {string} second\n * @return {string}\n */\nStringUtils.hashSCString = function (first, second) {\n  return BufferUtils.hashSC(new Buffer(first), new Buffer(second))\n}\n\n/**\n * Returns the pre-hash string used for Snapchat requests.\n *\n * @param {string} username\n * @param {string} password\n * @param {string} timestamp\n * @param {string} endpoint\n * @return {string}\n */\nStringUtils.getSCPreHashString = function (username, password, timestamp, endpoint) {\n  return username + '|' + password + '|' + timestamp + '|' + endpoint\n}\n\n/**\n * Attempts to parse the given string as JSON, returning null upon parse error.\n *\n * @param {string} input\n * @return {Object}\n */\nStringUtils.tryParseJSON = function (input) {\n  try {\n    return JSON.parse(input)\n  } catch (e) {\n    return null\n  }\n}\n\nStringUtils.matchGroup = function (input, regex, index) {\n  if (input && typeof input === 'string') {\n    var matches = input.match(regex)\n\n    if (matches && index < matches.length) {\n      return matches[index]\n    }\n  }\n\n  return null\n}\n\n/**\n * @param {string} first\n * @param {string} second\n * @return {string}\n */\nStringUtils.SCIdentifier = function (first, second) {\n  return first + '~' + second\n}\n\n/**\n * @param {string} sender\n * @return {string}\n */\nStringUtils.mediaIdentifier = function (sender) {\n  var hash = StringUtils.md5HashToHex(uuid.v4())\n  return sender.toUpperCase() + '~' + hash\n}\n\n/**\n * @return {string}\n */\nStringUtils.uniqueIdentifer = function () {\n  var hash = StringUtils.md5HashToHex(uuid.v4())\n  return hash.substr(0, 8) + '-' +\n    hash.substr(8, 4) + '-' +\n    hash.substr(12, 4) + '-' +\n    hash.substr(16, 4) + '-' +\n    hash.substr(20, 12)\n}\n\n/**\n * Encrypts the given password for use with Google's Android authentication.\n *\n * @param {string} gmailEmail\n * @param {string} gmailPassword\n * @return {string}\n */\nStringUtils.encryptGmailPassword = function (gmailEmail, gmailPassword) {\n  var keyBuffer = new Buffer(constants.core.googleDefaultPublicKey, 'base64')\n\n  var halfString1 = keyBuffer.toString('hex').substr(8, 256)\n  var modulus = bignum(halfString1, 16)\n\n  var halfString2 = keyBuffer.toString('hex').substr(272, 6)\n  var exponent = bignum(halfString2, 16)\n\n  var shasum = crypto.createHash('sha1')\n  shasum.update(keyBuffer.toString('binary'))\n\n  var signature = '00' + shasum.digest('hex').substr(0, 8)\n\n  var pem = ursa\n    .createPublicKeyFromComponents(modulus.toBuffer(), exponent.toBuffer())\n    .toPublicPem()\n    .toString()\n\n  var plain = gmailEmail + '\\x00' + gmailPassword\n\n  var key = new NodeRSA(pem)\n  var encrypted = key.encrypt(plain, 'hex')\n\n  var output = new Buffer(signature + encrypted.toString('hex'), 'hex')\n  var base64Output = output.toString('base64')\n\n  base64Output = base64Output.replace(/\\+/g, '-')\n  base64Output = base64Output.replace(/\\//g, '_')\n\n  return base64Output\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/gulpfile.js":"var gulp = require('gulp-npm-run')(require('gulp'))\nvar ghPages = require('gulp-gh-pages')\n\ngulp.task('deploy', [ 'docs' ], function () {\n  return gulp.src('./docs/**/*')\n    .pipe(ghPages())\n})\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/blob.js":"module.exports = SKBlob\n\nvar BufferUtils = require('../lib/buffer-utils')\nvar Story = require('./story')\nvar fileType = require('file-type')\nvar JSZip = require('jszip')\n\n/**\n * Snapchat Blob wrapper\n *\n * @class\n * @param {Buffer} data\n */\nfunction SKBlob (data) {\n  var self = this\n  if (!(self instanceof SKBlob)) return new SKBlob(data)\n\n  if (!(data instanceof Buffer)) {\n    data = new Buffer(data)\n  }\n\n  self._data = data\n  self._type = fileType(data)\n\n  self._isImage = BufferUtils.isImage(data)\n  self._isMPEG4 = BufferUtils.isMPEG4(data)\n  self._isVideo = self._isMPEG4\n  self._isMedia = BufferUtils.isMedia(data)\n\n  // TODO\n  self._overlay = null\n}\n\n/**\n * The underlying data for the image or video.\n *\n * @name SKBlob#data\n * @property {Buffer}\n * @readonly\n */\nObject.defineProperty(SKBlob.prototype, 'data', {\n  get: function () { return this._data }\n})\n\n/**\n * Information about the media type.\n *\n * @name SKBlob#type\n * @property {Buffer}\n * @readonly\n */\nObject.defineProperty(SKBlob.prototype, 'type', {\n  get: function () { return this._type }\n})\n\n/**\n * The overlay for the video if applicable.\n *\n * @name SKBlob#overlay\n * @property {Buffer}\n * @readonly\n */\nObject.defineProperty(SKBlob.prototype, 'overlay', {\n  get: function () { return this._overlay }\n})\n\n/**\n * Whether or not this blob represents an image (PNG or JPEG).\n *\n * @name SKBlob#isImage\n * @property {boolean}\n * @readonly\n */\nObject.defineProperty(SKBlob.prototype, 'isImage', {\n  get: function () { return this._isImage }\n})\n\n/**\n * Whether or not this blob represents a video (MPEG4).\n *\n * @name SKBlob#isVideo\n * @property {boolean}\n * @readonly\n */\nObject.defineProperty(SKBlob.prototype, 'isVideo', {\n  get: function () { return this._isVideo }\n})\n\n/**\n * Whether or not this blob represents an MPEG4 video.\n *\n * @name SKBlob#isMPEG4\n * @property {boolean}\n * @readonly\n */\nObject.defineProperty(SKBlob.prototype, 'isMPEG4', {\n  get: function () { return this._isMPEG4 }\n})\n\n/**\n * Whether or not this blob represents a supported image or video format.\n *\n * @name SKBlob#isMedia\n * @property {boolean}\n * @readonly\n */\nObject.defineProperty(SKBlob.prototype, 'isMedia', {\n  get: function () { return this._isMedia }\n})\n\n/**\n * Initializes and returns a new SKBlob from the given raw data.\n * Does not handle encrypted data.\n *\n * @static\n * @param {Buffer} data\n * @param {function} cb\n */\nSKBlob.initWithData = function (data, cb) {\n  if (!data) {\n    return cb('error empty blob')\n  }\n\n  if (typeof data === 'string') {\n    data = new Buffer(data)\n  }\n\n  if (BufferUtils.isCompressed(data)) {\n    var files = SKBlob.decompress(data)\n    return cb(null, files)\n  }\n\n  var blob = new SKBlob(data)\n  return cb(blob.isMedia ? null : 'unknown blob format', blob)\n}\n\n/**\n * Initializes and returns a new SKBlob from the given story and raw data.\n *\n * @static\n * @param {Buffer} data\n * @param {Story} story\n * @param {function} cb\n */\nSKBlob.initWithStoryData = function (data, story, cb) {\n  if (!(story instanceof Story)) {\n    throw new Error('SKBlob.initWithStoryData invalid story')\n  }\n\n  if (typeof data === 'string') {\n    data = new Buffer(data)\n  }\n\n  if (BufferUtils.isCompressed(data)) {\n    var files = SKBlob.decompress(data)\n    return cb(null, files)\n  }\n\n  return SKBlob.decrypt(data, story, cb)\n}\n\n/**\n * Unarchives blobs initialized with anonymous data.\n *\n * @static\n * @param {Buffer} data\n * @param {function} cb\n */\nSKBlob.decompress = function (data, cb) {\n  var zip = new JSZip(data)\n  var files = Object.keys(zip.files).map(function (filename) {\n    var decompressed = zip.file(filename).asNodeBuffer()\n    return {\n      name: filename,\n      blob: new SKBlob(decompressed)\n    }\n  })\n  return files\n}\n\n/**\n * @static\n * @param {Buffer} data\n * @param {Story} story\n * @param {function} cb\n */\nSKBlob.decrypt = function (data, story, cb) {\n  if (!(story instanceof Story)) {\n    throw new Error('SKBlob.decrypt invalid story')\n  }\n\n  if (!BufferUtils.isCompressed(data) && !BufferUtils.isMedia(data) && story) {\n    data = BufferUtils.decryptStory(data, story.mediaKey, story.mediaIV)\n  }\n\n  if (BufferUtils.isCompressed(data)) {\n    var files = SKBlob.decompress(data)\n    return cb(null, files)\n  }\n\n  var blob = new SKBlob(data)\n  return cb(blob.isMedia ? null : 'unknown blob format', blob)\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/story.js":"module.exports = Story\n\nvar Promise = require('bluebird')\n\nvar BufferUtils = require('../lib/buffer-utils')\nvar Snapchat = require('../')\n\n/**\n * Snapchat Story\n *\n * @class\n * @param {Snapchat} client\n * @param {Object} params\n */\nfunction Story (client, params) {\n  var self = this\n  if (!(self instanceof Story)) return new Story(client, params)\n  if (!(client instanceof Snapchat)) throw new Error('invalid client')\n\n  self.client = client\n\n  // null until you call load\n  // self.blob = null\n\n  // null until you call loadThumbnail\n  // self.thumbnailBlob = null\n\n  self.author = params['username']\n  self.viewed = !!params['viewed']\n  self.shared = !!params['is_shared']\n  self.zipped = !!params['zipped']\n  self.matureContent = !!params['mature_content']\n  self.needsAuth = !!params['needs_auth']\n\n  self.duration = params['time'] || 0\n\n  self.identifier = params['id']\n  self.text = params['caption_text_display']\n  self.clientIdentifier = params['client_id']\n\n  if (params['story_filter_id'].length) {\n    self.storyFilterIdentifier = params['story_filter_id']\n  }\n  self.adCanFollow = !!params['ad_can_follow']\n\n  self.mediaIdentifier = params['media_id']\n  self.mediaIV = params['media_iv']\n  self.mediaKey = params['media_key']\n  self.mediaKind = params['media_type'] || 0\n  self.mediaURL = params['media_url']\n\n  self.thumbIV = params['thumbnail_iv']\n  self.thumbURL = params['thumbnail_url']\n\n  self.timeLeft = params['time_left'] || 0\n  self.created = new Date(+params['timestamp']).toISOString()\n}\n\n/**\n * The underlying data for the image or video.\n *\n * @name Story#suggestedFilename\n * @property {string}\n */\nObject.defineProperty(Story.prototype, 'suggestedFilename', {\n  get: function () {\n    var self = this\n\n    if (!self.blob) {\n      return null\n    } else if (self.blob.isImage || self.blob.isVideo) {\n      return self.identifier + BufferUtils.getFileExtension(self.blob.data)\n    } else {\n      return self.identifier\n    }\n  }\n})\n\n/**\n * Loads the blob for the story. If successful, the blob property of the original Story object will contain the story's blob data.\n */\nStory.prototype.load = function (cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    self.client.stories.loadStoryBlob(self, function (err, blob) {\n      if (err) {\n        return reject(err)\n      }\n\n      // seperate media & overlay data\n      if (Array.isArray(blob)) {\n        if (blob.length > 2) {\n        }\n        self.overlay = blob[1].blob\n        blob = blob[0].blob\n      }\n\n      self.blob = blob\n      return resolve(blob)\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Loads the blob for the story thumbnail. If successful, the thumbnailBlob property of the original Story object will contain the story's thumbnail blob data.\n */\nStory.prototype.loadThumbnail = function (cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    self.client.stories.loadStoryThumbnailBlob(self, function (err, blob) {\n      if (err) {\n        return reject(err)\n      }\n\n      self.thumbnailBlob = blob\n      return resolve(self)\n    })\n  }).nodeify(cb)\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/cash-transaction.js":"module.exports = CashTransaction\n\n/**\n * Snapchat CashTransaction\n *\n * @class\n * @param {Object} params\n */\nfunction CashTransaction (params) {\n  var self = this\n  if (!(self instanceof CashTransaction)) return new CashTransaction(params)\n\n  // currently unused\n  throw new Error('TODO')\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/conversation.js":"module.exports = Conversation\n\nvar debug = require('debug')('snapchat:conversation')\nvar Snap = require('./snap')\n\nvar Message = require('./message')\nvar CashTransaction = require('./cash-transaction')\nvar Transaction = require('./transaction')\n\n/**\n * Snapchat Conversation\n *\n * @class\n * @param {Object} params\n */\nfunction Conversation (params) {\n  var self = this\n  if (!(self instanceof Conversation)) return new Conversation(params)\n\n  var convoMessages = params['conversation_messages'] || { }\n  var lastChatActions = params['last_chat_actions']\n  var lastTransaction = params['last_cash_transaction']\n  var pendingRecievedSnaps = params['pending_received_snaps'] || []\n  var messages = convoMessages['messages'] || []\n  var lastSnap = params['last_snap']\n  var lastInteraction = +params['last_interaction_ts']\n\n  self.messagingAuth = convoMessages['messaging_auth']\n\n  self.state = params['conversation_state']\n  self.identifier = params['id']\n  self.pagination = params['iter_token']\n\n  self.lastSnap = lastSnap ? new Snap(lastSnap) : null\n  self.lastTransaction = lastTransaction ? new Transaction(lastTransaction) : null\n  self.lastInteraction = lastInteraction > 0 ? new Date(lastInteraction) : null\n  if (lastChatActions) {\n    // self.lastChatType = SKChatTypeFromString(lastChatActions['last_write_type'])\n    // self.lastChatRead = +NSDate dateWithTimeIntervalSince1970:[lastChatActions['last_read_timestamp']/1000]\n    // self.lastChatWrite = +NSDate dateWithTimeIntervalSince1970:[lastChatActions['last_write_timestamp']/1000]\n    self.lastChatReader = lastChatActions['last_reader']\n    self.lastChatWriter = lastChatActions['last_writer']\n  }\n\n  self.participants = params['participants'] || self.identifier.split('~')\n  self.usersWithPendingChats = params['pending_chats_for'] || []\n\n  // Messages\n  self.messages = messages.map(function (message) {\n    if (message['snap']) {\n      return new Snap(message['snap'])\n    } else if (message['chat_message']) {\n      return new Message(message['chat_message'])\n    } else if (message['cash_transaction']) {\n      return new CashTransaction(message['chat_transaction'])\n    } else {\n      debug('Unhandled conversation message type:%s', message)\n      return null\n    }\n  })\n\n  // Pending recieved snaps\n  self.pendingRecievedSnaps = pendingRecievedSnaps.map(function (snap) {\n    return new Snap(snap)\n  })\n}\n\nConversation.prototype.addMessagesFromConversation = function (convo) {\n  var self = this\n  if (!convo.messages.count) return\n\n  self.messages = self.messages.concat(convo.messages)\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/snap.js":"module.exports = Snap\n\n/**\n * Snapchat Snap\n *\n * @class\n * @param {Object} params\n */\nfunction Snap (params) {\n  var self = this\n  if (!(self instanceof Snap)) return new Snap(params)\n\n  // null until you call load\n  self.blob = null\n\n  // null if snap is outgoing\n  self.sender = params['sn']\n\n  // null if snap is incoming\n  self.recipient = params['rp']\n\n  self.identifier = params['id']\n  self.conversationIdentifier = params['c_id']\n  self.mediaKind = params['m'] | 0\n  self.status = params['st'] | 0\n  self.screenshots = params['c'] | 0\n  // 0 if snap is outgoing\n  self.timer = params['t'] | 0\n  // actual length of the video or the same as timer for images. 0 if snap is outgoing\n  self.mediaTimer = +params['rp']\n  self.sentDate = new Date(+(params['sts'] || params['ts']))\n  self.zipped = !!params['zipped']\n}\n\n// TODO: Snap.load is currently unused\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/message.js":"module.exports = Message\n\nvar debug = require('debug')('snapchat:message')\n\nvar constants = require('../lib/constants')\n\n/**\n * Snapchat Message\n *\n * @class\n * @param {Object} params\n */\nfunction Message (params) {\n  var self = this\n  if (!(self instanceof Message)) return new Message(params)\n\n  var message = params['chat_message'] || params\n  var header = message['header']\n  var body = message['body'] || { }\n  var media = body['media']\n  var type = body['type']\n\n  self.identifier = message['id']\n  self.messageIdentifier = message['chat_message_id']\n  self.pagination = params['iter_token']\n  self.messageKind = constants.messageKindFromString(type)\n  self.created = new Date(+message['timestamp'])\n\n  if (self.messageKind === null) {\n    debug('invalid MessageKind (%s %j)', type, params)\n  } else if (self.messageKind === constants.MessageKind.Text.value) {\n    self.text = body['text']\n  } else if (media) {\n    self.mediaIdentifier = media['media_id']\n    self.mediaSize = {\n      'width': media['width'] | 0,\n      'height': media['height'] | 0\n    }\n    self.mediaIV = media['iv']\n    self.mediaKey = media['key']\n    self.mediaType = media['media_type']\n\n    if (self.mediaType) {\n      self.mediaType = 'UNSPECIFIED'\n    } else if (self.mediaType !== 'VIDEO') {\n      debug('new message type (%s)', self.mediaType)\n    }\n  }\n\n  self.conversationIdentifier = header['conv_id']\n\n  self.recipients = header['to']\n  self.sender = header['from']\n\n  self.index = message['seq_num'] | 0\n  self.savedState = message['saved_state']\n  self.type = message['type']\n\n  if (self.type !== 'chat_message') {\n    debug('unknown chat message type (%s %j)', self.type, params)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/transaction.js":"module.exports = Transaction\n\n/**\n * Snapchat Transaction\n *\n * @class\n * @param {Object} params\n */\nfunction Transaction (params) {\n  var self = this\n  if (!(self instanceof Transaction)) return new Transaction(params)\n\n  throw new Error('TODO')\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/filter.js":"module.exports = Filter\n\n/**\n * Snapchat Filter\n *\n * @class\n * @param {Object} params\n */\nfunction Filter (params) {\n  var self = this\n  if (!(self instanceof Filter)) return new Filter(params)\n\n  self.identifier = params['filter_id']\n  self.priority = params['priority'] | 0\n  self.hideSponsoredSlug = !!params['hide_spondored_slug']\n  self.imageURL = params['image']\n  self.isDynamic = !!params['is_dynamic_geofilter']\n  self.isSponsored = !!params['is_sponsoed']\n  self.position = params['position']\n  self.prepositioned = !!params['prepositioned']\n  self.prepositionedImageURL = params['prepositioned_image']\n\n  var geofence = params['geofence']\n  var coords = geofence['coordinates']\n\n  self.geofenceIdentifier = geofence['id']\n  self.coordinates = (coords || [ ]).map(function (coord) {\n    return {\n      lat: coord['lat'],\n      lng: coord['long']\n    }\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/found-friend.js":"module.exports = FoundFriend\n\n/**\n * Snapchat FoundFriend\n *\n * @class\n * @param {Object} params\n */\nfunction FoundFriend (params) {\n  var self = this\n  if (!(self instanceof FoundFriend)) return new FoundFriend(params)\n\n  self.displayName = params['display']\n  self.username = params['name']\n  self.isPrivate = !!params['type']\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/location.js":"module.exports = SKLocation\n\nvar Filter = require('./filter')\n\n/**\n * Snapchat location-specific data\n *\n * @class\n * @param {Object} params\n */\nfunction SKLocation (params) {\n  var self = this\n  if (!(self instanceof SKLocation)) return new SKLocation(params)\n\n  self.weather = params['weather']\n  self.ourStoryAuths = params['our_story_auths']\n  self.preCacheGeofilters = params['pre_cache_geofilters']\n\n  self.filters = params['filters'].map(function (filter) {\n    return new Filter(filter)\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/nearby-user.js":"module.exports = NearbyUser\n\n/**\n * Snapchat NearbyUser\n *\n * @class\n * @param {string} username\n * @param {string} identifier\n */\nfunction NearbyUser (username, identifier) {\n  var self = this\n  if (!(self instanceof NearbyUser)) return new NearbyUser(username, identifier)\n\n  self.username = username\n  self.identifier = identifier\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/session.js":"module.exports = Session\n\nvar constants = require('../lib/constants')\nvar Snapchat = require('../')\nvar User = require('./user')\nvar Conversation = require('./conversation')\nvar UserStory = require('./user-story')\nvar StoryCollection = require('./story-collection')\n\n/**\n * Snapchat Session\n *\n * @class\n * @param {Snapchat} client\n * @param {Object} params\n */\nfunction Session (client, params) {\n  var self = this\n  if (!(self instanceof Session)) return new Session(client, params)\n  if (!(client instanceof Snapchat)) throw new Error('invalid client')\n\n  self.client = client\n\n  var storiesResponse = params['stories_response']\n  var friendsResponse = params['friends_response']\n  var updatesResponse = params['updates_response']\n  var identity = params['identity_check_response']\n  var features = updatesResponse['feature_settings']\n  var discover = params['discover']\n  var messagingGate = params['messaging_gateway_info']\n\n  var friendStories = storiesResponse['friend_stories'] || []\n  var myStories = storiesResponse['my_stories'] || []\n  // var groupStories = storiesResponse['my_group_stories'] || []\n\n  var friends = friendsResponse['friends'] || []\n  var addedFriends = friendsResponse['added_friends'] || []\n  var conversations = params['conversations_response'] || []\n\n  self.backgroundFetchSecret = params['background_fetch_secret_key']\n  self.bestFriendUsernames = friendsResponse['bests'] || []\n\n  self.storiesDelta = !!storiesResponse['friend_stories_delta']\n  self.emailVerified = !!identity['is_email_verified']\n  self.highAccuracyRequiredForNearby = !!identity['is_high_accuracy_required_for_nearby']\n  self.requirePhonePasswordConfirmed = !!identity['require_phone_password_confirmed']\n  self.redGearDurationMilliseconds = +identity['red_gear_duration_millis']\n  self.suggestedFriendFetchThresholdHours = identity['suggested_friend_fetch_threshold_hours'] | 0\n\n  self.messagingGatewayAuth = messagingGate['gateway_auth_token']\n  self.messagingGatewayServer = messagingGate['gateway_server']\n\n  // Discover\n  self.discoverSupported = (discover['compatibility'] === 'supported')\n  self.discoverSharingEnabled = !!discover['sharing_enabled']\n  self.discoverGetChannels = discover['get_channels']\n  self.discoverResourceParamName = discover['resource_parameter_name']\n  self.discoverResourceParamValue = discover['resource_parameter_value']\n  self.discoverVideoCatalog = discover['video_catalog']\n\n  // Friends\n  self.friends = friends.filter(function (friend) {\n    return friend.name !== updatesResponse['username'] && friend.expiration === 0\n  }).map(function (friend) {\n    return new User(friend)\n  })\n\n  // Added friends\n  self.addedFriends = addedFriends.map(function (friend) {\n    return new User(friend)\n  })\n\n  // Conversations\n  self.conversations = conversations.map(function (conversation) {\n    return new Conversation(conversation)\n  })\n\n  // Story collections\n  self.stories = friendStories.map(function (collection) {\n    return new StoryCollection(self.client, collection)\n  })\n\n  // User stories\n  self.userStories = myStories.map(function (story) {\n    return new UserStory(story)\n  })\n\n  // Group stories?\n  self.groupStories = [ ] // TODO\n\n  // Added me but not added back\n  self.pendingRequests = [ ] // TODO\n\n  // Cash info\n  self.canUseCash = !!updatesResponse['allowed_to_use_cash']\n  self.isCashActive = !!updatesResponse['is_cash_active']\n  self.cashCustomerIdentifier = updatesResponse['cash_customer_id']\n  self.cashClientProperties = updatesResponse['client_properties']\n  self.cashProvider = updatesResponse['cash_provider']\n\n  // Basic user info\n  self.username = updatesResponse['username']\n  self.email = updatesResponse['email']\n  self.mobileNumber = updatesResponse['mobile']\n  self.recieved = updatesResponse['recieved'] | 0\n  self.sent = updatesResponse['sent'] | 0\n  self.score = updatesResponse['score'] | 0\n  self.recents = updatesResponse['recents'] || []\n  self.requests = updatesResponse['requests'] || []\n\n  // Account information\n  self.addedFriendsTimestamp = new Date(updatesResponse['added_friends_timestamp'])\n  self.authToken = updatesResponse['auth_token']\n  self.canSeeMatureContent = !!updatesResponse['can_view_mature_content']\n  self.countryCode = updatesResponse['country_code'] || 'US'\n  self.lastTimestamp = new Date(updatesResponse['cash_provider'])\n  self.devicetoken = updatesResponse['device_token']\n  self.canSaveStoryToGallery = !!updatesResponse['enable_save_story_to_gallery']\n  self.canVideoTranscodingAndroid = !!updatesResponse['enable_video_transcoding_android']\n  self.imageCaption = !!updatesResponse['image_caption']\n  self.requireRefreshingProfileMedia = !!updatesResponse['require_refreshing_profile_media']\n  self.isTwoFAEnabled = !!updatesResponse['is_two_fa_enabled']\n  self.lastAddressBookUpdateDate = new Date(updatesResponse['last_address_book_updated_date'])\n  self.lastReplayedSnapDate = new Date(updatesResponse['last_replayed_snap_timestamp'])\n  self.logged = !!updatesResponse['logged']\n  self.mobileVerificationKey = updatesResponse['mobile_verification_key']\n  self.canUploadRawThumbnail = !!updatesResponse['raw_thumbnail_upload_enabled']\n  self.seenTooltips = updatesResponse['seen_tooltips']\n  self.shouldCallToVerifyNumber = !!updatesResponse['should_call_to_verify_number']\n  self.shouldTextToVerifyNumber = !!updatesResponse['should_send_text_to_verify_number']\n  self.snapchatPhoneNumber = updatesResponse['snapchat_phone_number']\n  self.studySettings = updatesResponse['study_settings']\n  self.targeting = updatesResponse['targeting']\n  self.userIdentifier = updatesResponse['user_id']\n  self.videoFiltersEnabled = !!updatesResponse['video_filters_enabled']\n  self.QRPath = updatesResponse['qr_path']\n\n  // Preferences\n  self.enableNotificationSounds = !!updatesResponse['notification_sound_setting']\n  self.numberOfBestFriends = updatesResponse['number_of_best_friends'] | 0\n  self.privacyEveryone = !updatesResponse['snap_p']\n  self.isSearchableByPhoneNumber = !!updatesResponse['searchable_by_phone_number']\n  // self.storyPrivacy = SKStoryPrivacyFromString(updatesResponse['story_privacy']) // TODO\n\n  // Features\n  self.enableFrontFacingFlash = !!features[constants.featureSettings.frontFacingFlash]\n  self.enablePowerSaveMode = !!features[constants.featureSettings.powerSaveMode]\n  self.enableReplaySnaps = !!features[constants.featureSettings.replaySnaps]\n  self.enableSmartFilters = !!features[constants.featureSettings.smartFilters]\n  self.enableSpecialText = !!features[constants.featureSettings.specialText]\n  self.enableSwipeCashMode = !!features[constants.featureSettings.swipeCashMode]\n  self.enableVisualFilters = !!features[constants.featureSettings.visualFilters]\n  self.enableTravelMode = !!features[constants.featureSettings.travelMode]\n}\n\n/**\n * @param {string} username\n * @return {User|null}\n */\nSession.prototype.getFriend = function (username) {\n  var self = this\n\n  // TODO: use cached map of username->friend\n  for (var i = 0; i < self.friends.length; ++i) {\n    var friend = self.friends[i]\n\n    if (friend.username === username) {\n      return friend\n    }\n  }\n\n  return null\n}\n\n/**\n * @param  {string} username\n * @return {Story|null}\n */\nSession.prototype.getStory = function (username) {\n  var self = this\n\n  // TODO: use cached map of username->story\n  for (var i = 0; i < self.stories.length; ++i) {\n    var story = self.stories[i]\n\n    if (story.username === username) {\n      return story\n    }\n  }\n\n  return null\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/shared-story-description.js":"module.exports = SharedStoryDescription\n\n/**\n * Snapchat SharedStoryDescription\n *\n * @class\n * @param {Object} params\n */\nfunction SharedStoryDescription (params) {\n  var self = this\n  if (!(self instanceof SharedStoryDescription)) return new SharedStoryDescription(params)\n\n  // ie \"Campaign 2016 is a collection of Snaps from Snapchatters in Iowa.\"\n  self.friendNote = params['FRIEND']\n\n  // ie \"While you're here, you may submit Snaps to Our Campaign Story. To opt out of this location-based feature, turn off Filters in Settings.\"\n  self.localPostBody = params['LOCAL_POST_BODY']\n\n  // ie \"Post Snap to Campaign?\"\n  self.localPostTitle = params['LOCAL_POST_TITLE']\n\n  // ie \"Campaign 2016 is a collection of Snaps from Snapchatters in Iowa.\"\n  self.localViewBody = params['LOCAL_VIEW_BODY']\n\n  // ie \"Our Story\"\n  self.localViewTitle = params['LOCAL_VIEW_TITLE']\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/snap-options.js":"module.exports = SnapOptions\n\n/**\n * Snapchat SnapOptions\n *\n * @class\n * @param {Array<string>|string} recipients An array of username strings.\n * @param {string=} text The text sent in the snap.\n * @param {number=} timer Optional length of the snap. Defaults to 3\n */\nfunction SnapOptions (recipients, text, timer) {\n  var self = this\n  if (!(self instanceof SnapOptions)) return new SnapOptions(recipients, text, timer)\n\n  self.recipients = Array.isArray(recipients) ? recipients : [ recipients ]\n  self.text = text || ''\n  self.timer = timer || 3\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/story-collection.js":"module.exports = StoryCollection\n\nvar xtend = require('xtend')\n\nvar Snapchat = require('../')\nvar Story = require('./story')\n\n/**\n * Snapchat StoryCollection\n *\n * @class\n * @param {Snapchat} client\n * @param {Object} params\n */\nfunction StoryCollection (client, params) {\n  var self = this\n  if (!(self instanceof StoryCollection)) return new StoryCollection(client, params)\n  if (!(client instanceof Snapchat)) throw new Error('invalid client')\n\n  self.client = client\n\n  var thumbs = params['thumbnails']\n\n  // The username of the user associated with this story collection.\n  self.username = params['username']\n  // Whether this story contains explicit content.\n  self.matureContent = !!params['mature_content']\n\n  // shared stories only\n\n  // Only applies to shared stories.\n  self.adPlacementData = params['ad_placement_metadata']\n  // The display name of the shared story.\n  self.displayName = params['display_name']\n  // The identifier of the shared story.\n  self.sharedIdentifier = params['shared_id']\n  // Whether the shared story is local or not.\n  self.isLocal = !!params['is_local']\n\n  // Only applies to shared stories.\n  if (thumbs) {\n    // The thumbnail for the viewed state of the story.\n    self.viewedThumbnail = thumbs['viewed']['url']\n    // The thumbnail for the unviewed state of the story.\n    self.unviewedThumbnail = thumbs['unviewed']['url']\n\n    self.viewedThumbnailNeedsAuth = !!thumbs['viewed']['needs_auth']\n    self.unviewedThumbnailNeedsAuth = !!thumbs['unviewed']['needs_auth']\n  }\n\n  // An array of Story objects.\n  self.stories = (params['stories'] || []).map(function (story) {\n    xtend(story.story, {\n      'viewed': story.viewed\n    })\n    return new Story(self.client, story.story)\n  })\n}\n\n/**\n * Whether or not the stories in this collection are shared.\n *\n * @name StoryCollection#isSharedStory\n * @property {boolean}\n */\nObject.defineProperty(StoryCollection.prototype, 'isSharedStory', {\n  get: function () {\n    return this.stories[0] && this.stories[0].shared\n  }\n})\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/story-note.js":"module.exports = StoryNote\n\n/**\n * Snapchat StoryNote\n *\n * @class\n * @param {Object} params\n */\nfunction StoryNote (params) {\n  var self = this\n  if (!(self instanceof StoryNote)) return new StoryNote(params)\n\n  // who viewed the story\n  self.viewer = params['viewer']\n\n  // when the story was viewed by the viewer\n  self.viewDate = new Date(+params['timestamp'])\n\n  // whether or not the viewer took a screenshot of the story\n  self.screenshot = !!params['screenshotted']\n\n  // obscure data. not sure what is's for but it has the following format:\n  // {\n  //   mField : \"123456.023Z\"\n  //   mId    : \"username~unixtime\"\n  //   mKey   : \"story:{username}:YYYYMMDD\"\n  // }\n  self.storyPointer = params['storypointer']\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/story-options.js":"module.exports = StoryOptions\n\n/**\n * Snapchat StoryOptions\n *\n * @class\n * @param {string} text\n * @param {number} timer\n * @param {boolean} cameraFrontFacing\n */\nfunction StoryOptions (text, timer, cameraFrontFacing) {\n  var self = this\n  if (!(self instanceof StoryOptions)) return new StoryOptions(text, timer, cameraFrontFacing)\n\n  self.text = text\n  self.timer = timer || 3\n  self.cameraFrontFacing = !!cameraFrontFacing\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/story-updater.js":"module.exports = StoryUpdater\n\n/**\n * Snapchat StoryUpdater\n *\n * @class\n * @param {string} storyID\n * @param {string} timestamp\n * @param {number} screenshotCount\n */\nfunction StoryUpdater (storyID, timestamp, screenshotCount) {\n  var self = this\n  if (!(self instanceof StoryUpdater)) return new StoryUpdater(storyID, timestamp, screenshotCount)\n\n  self.storyID = storyID\n  self.timestamp = timestamp\n  self.screenshotCount = screenshotCount\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/user.js":"module.exports = User\n\n/**\n * Snapchat User\n *\n * @class\n * @param {Object} params\n */\nfunction User (params) {\n  var self = this\n  if (!(self instanceof User)) return new User(params)\n\n  self.username = params['name']\n  self.displayName = params['display'] || params['name']\n  self.userIdentifier = params['user_id']\n  self.addedIncoming = params['direction'] === 'INCOMING'\n  self.ignoredLink = !!params['ignored_link']\n  self.privacy = params['type'] | 0\n  self.expiration = new Date(+params['expiration'])\n\n  self.friendmoji = params['friendmoji_string']\n  self.venue = params['venue'] || ''\n  self.sharedStoryIdentifier = params['shared_story_id'] || ''\n  self.canSeeCustomStories = !!params['can_see_custom_stories']\n  self.needsLove = !!params['needs_love']\n  self.isSharedStory = !!params['is_shared_story']\n  self.isLocalStory = !!params['local_story']\n  self.hasCustomDescription = !!params['has_custom_description']\n  self.decayThumbnail = !!params['dont_decay_thumbnail']\n\n  if (params['ts']) {\n    self.timestamp = new Date(+params['ts'])\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/models/user-story.js":"module.exports = UserStory\n\nvar StoryNote = require('./story-note')\n\n/**\n * Snapchat UserStory\n *\n * @class\n * @param {Object} params\n */\nfunction UserStory (params) {\n  var self = this\n  if (!(self instanceof UserStory)) return new UserStory(params)\n\n  var extras = params['story_extras']\n  var storyNotes = params['story_notes']\n\n  self.screenshotCount = extras['screenshot_count'] | 0\n  self.viewCount = extras['view_count'] | 0\n\n  self.notes = (storyNotes || [ ]).map(function (note) {\n    return new StoryNote(note)\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/routes/account.js":"module.exports = Account\n\nvar debug = require('debug')('snapchat:account')\nvar Promise = require('bluebird')\n\nvar constants = require('../lib/constants')\n\nvar SKBlob = require('../models/blob')\n\n/**\n * Snapchat wrapper for account-related API calls.\n *\n * @class\n * @param {Object} opts\n */\nfunction Account (client, opts) {\n  var self = this\n  if (!(self instanceof Account)) return new Account(client, opts)\n  if (!opts) opts = {}\n\n  self.client = client\n}\n\n/**\n * Updates the number of best friends to display.\n *\n * @param {number} number A number from 3 to 7. Defaults to 3 and will max out at 7.\n * @param {function} cb\n */\nAccount.prototype.updateBestFriendsCount = function (number, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Account.updateBestFriendsCount (%d)', number)\n\n    if (number < 3) number = 3\n    if (number > 7) number = 7\n\n    self.client.post(constants.endpoints.account.setBestsCount, {\n      'num_best_friends': number | 0,\n      'username': self.client.username\n    }, function (err, result) {\n      if (err) {\n        return reject(err)\n      } else if (result) {\n        self.client.session.bestFriendUsernames = result['best_friends']\n        return resolve()\n      }\n\n      return reject(new Error('Snapchat.Account.updateBestFriendsCount parse error'))\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Updates who can send you snaps.\n *\n * @param privacy SnapPrivacy.Friends or SnapPrivacy.Everyone. Defaults to SnapPrivacy.Friends.\n * @param {function} cb\n */\nAccount.prototype.updateSnapPrivacy = function (privacy, cb) {\n  var self = this\n  debug('Account.updateSnapPrivacy (%d)', privacy)\n\n  privacy = Math.min(privacy, 1) | 0\n\n  return self.client.post(constants.endpoints.account.settings, {\n    'action': 'updatePrivacy',\n    'privacySetting': privacy,\n    'username': self.client.username\n  }, cb)\n}\n\n/**\n * Updates who can see your stories. \\e friends is only necessary when using StoryPrivacy.Custom.\n *\n * @param {number} privacy StoryPrivacy.Everyone, StoryPrivacy.Friends, StoryPrivacy.Custom.\n * @param {Array<string>=} friends Optional list of strings of usernames to hide your stories from. Used only when privacy is StoryPrivacy.Custom.\n * @param {function} cb\n */\nAccount.prototype.updateStoryPrivacy = function (privacy, friends, cb) {\n  var self = this\n  debug('Account.updateStoryPrivacy (%d)', privacy)\n\n  if (typeof friends === 'function') {\n    cb = friends\n    friends = null\n  }\n\n  var params = {\n    'action': 'updateStoryPrivacy',\n    'privacySetting': constants.stringFromStoryPrivacy(privacy | 0),\n    'username': self.client.username\n  }\n\n  if (friends) {\n    params.storyFriendsToBlock = friends\n  }\n\n  return self.client.post(constants.endpoints.account.settings, params, cb)\n}\n\n/**\n * Updates your account's email address.\n *\n * @param {string} address Your new email address.\n * @param {function} cb\n */\nAccount.prototype.updateEmail = function (address, cb) {\n  var self = this\n  debug('Account.updateEmail (%s)', address)\n\n  return self.client.post(constants.endpoints.account.settings, {\n    'action': 'updateEmail',\n    'email': address,\n    'username': self.client.username\n  }, cb)\n}\n\n/**\n * Updates whether your account can be found with your phone number.\n *\n * @param {boolean} searchable The new value for this preference.\n * @param {function} cb\n */\nAccount.prototype.updateSearchableByNumber = function (searchable, cb) {\n  var self = this\n  debug('Account.updateSearchableByNumber (%d)', searchable)\n\n  return self.client.post(constants.endpoints.account.settings, {\n    'action': 'updateSearchableByPhoneNumber',\n    'searchable': !!searchable,\n    'username': self.client.username\n  }, cb)\n}\n\n/**\n * Updates your 'notification sounds' preference.\n *\n * @param {boolean} enableSound The new value for this preference.\n * @param {function} cb\n */\nAccount.prototype.updateNotificationSoundSetting = function (enableSound, cb) {\n  var self = this\n  debug('Account.updateNotificationSoundSetting (%d)', enableSound)\n\n  return self.client.post(constants.endpoints.account.settings, {\n    'action': 'updateNotificationSoundSetting',\n    'notificationSoundSetting': enableSound ? 'ON' : 'OFF',\n    'username': self.client.username\n  }, cb)\n}\n\n/**\n * Updates your display name.\n *\n * Your 'display name' is what your contact name defaults to when someone new adds you, not your username.\n * @param {string} displayName Your new display name.\n * @param {function} cb\n */\nAccount.prototype.updateDisplayName = function (displayName, cb) {\n  var self = this\n  debug('Account.updateDisplayName (%s)', displayName)\n\n  return self.client.friends.updateDisplayNameForUser(self.client.username, displayName, cb)\n}\n\n/**\n * Updates your account's feature settings.\n *\n * See constants.Feature for valid keys. Invalid keys will be silently ignored.\n * @warning Raises an exception if \\e settings contains more than 8 key-value pairs.\n *\n * @param Object settings A dictionary of string-boolean pairs. Missing keys-value pairs default to the current values. Behavior is undefined for values other than booleans.\n * @param {function} cb\n */\nAccount.prototype.updateFeatureSettings = function (settings, cb) {\n  var self = this\n  debug('Account.updateFeatureSettings')\n\n  var features = { }\n  features[constants.featureSettings.frontFacingFlash] = settings[constants.featureSettings.frontFacingFlash] || self.client.session.enableFrontFacingFlash\n  features[constants.featureSettings.replaySnaps] = settings[constants.featureSettings.replaySnaps] || self.client.session.enableReplaySnaps\n  features[constants.featureSettings.smartFilters] = settings[constants.featureSettings.smartFilters] || self.client.session.enableSmartFilters\n  features[constants.featureSettings.visualFilters] = settings[constants.featureSettings.visualFilters] || self.client.session.enableVisualFilters\n  features[constants.featureSettings.powerSaveMode] = settings[constants.featureSettings.powerSaveMode] || self.client.session.enablePowerSaveMode\n  features[constants.featureSettings.specialText] = settings[constants.featureSettings.specialText] || self.client.session.enableSpecialText\n  features[constants.featureSettings.swipeCashMode] = settings[constants.featureSettings.swipeCashMode] || self.client.session.enableSwipeCashMode\n  features[constants.featureSettings.travelMode] = settings[constants.featureSettings.travelMode] || self.client.session.enableTravelMode\n\n  return self.client.post(constants.endpoints.update.featureSettings, {\n    'settings': JSON.stringify(features),\n    'username': self.client.username\n  }, cb)\n}\n\n/**\n * Downloads your account's snaptag, a personal Snapchat QR code.\n *\n * @param {function} cb\n */\nAccount.prototype.downloadSnaptag = function (cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Account.downloadSnaptag')\n\n    self.client.post(constants.endpoints.account.snaptag, {\n      'image': self.client.session.QRPath,\n      'type': 'SVG',\n      'username': self.client.username\n    }, function (err) {\n      if (err) {\n        return reject(err)\n      }\n\n      // TODO: this returns application/json but it's actually an XML doc:\n      // '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\\n<svg height=\"320\" version=\"1.1\" viewBox=\"0 0 320 320\" width=\"320\" xmlns=\"http://www.w3.org/2000/svg\">\\n  <path d=\"M162.31,52.4......74\" fill=\"#FFFC00\"/>\\n</svg>\\n'\n      return reject(new Error('downloadSnaptag TODO'))\n      // SKBlob.initWithData(body, cb)\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Uploads a new animated avatar. Not working yet.\n *\n * @param {Array<Buffer>} images An array of 5 image Buffer objects.\n * @param {function} cb\n */\nAccount.prototype.uploadAvatar = function (images, cb) {\n  return new Promise(function (resolve, reject) {\n    debug('Account.uploadAvatar')\n\n    // SKEPAccount.avatar.set\n    // multipart/form-data; takes a single 'data' parameter in addition to the usual 'username' param\n    return reject(new Error('Account.uploadAvatar TODO'))\n  }).nodeify(cb)\n}\n\n/**\n * Downloads the animated avatar for user. Currently encrypted, or something.\n *\n * @param {string} username The username tied to the avatar to download.\n * @param {function} cb\n */\nAccount.prototype.downloadAvatar = function (username, cb) {\n  var self = this\n  return new Promise(function (resolve, reject) {\n\n    debug('Account.downloadAvatar')\n\n    self.client.post(constants.endpoints.account.avatar.get, {\n      'username_image': username,\n      'username': self.client.username,\n      'size': 'MEDIUM'\n    }, function (err, body) {\n      if (err) {\n        return reject(err)\n      } else {\n        SKBlob.initWithData(body, function (err, blob) {\n          if (err) {\n            return reject(err)\n          }\n          return resolve(blob)\n        })\n      }\n    })\n\n  }).nodeify(cb)\n}\n\n/**\n * Updates your TOS agreement status for each of the three Terms of Service.\n *\n * @param {boolean} snapcash\n * @param {boolean} snapcashV2\n * @param {boolean} square\n * @param {function} cb\n */\nAccount.prototype.updateTOSAgreementStatus = function (snapcash, snapcashV2, square, cb) {\n  var self = this\n  debug('Account.updateTOSAgreementStatus')\n\n  var agreements = {\n    'snapcash_new_tos_accepted': snapcash ? 'true' : 'false',\n    'snapcash_tos_v2_accepted': snapcashV2 ? 'true' : 'false',\n    'square_tos_accepted': square ? 'true' : 'false'\n  }\n\n  return self.client.post(constants.endpoints.update.user, {\n    'username': self.client.username,\n    'agreements': JSON.stringify(agreements)\n  }, cb)\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/routes/chat.js":"module.exports = Chat\n\nvar debug = require('debug')('snapchat:chat')\nvar async = require('async')\nvar extend = require('xtend')\nvar Promise = require('bluebird')\n\nvar constants = require('../lib/constants')\nvar StringUtils = require('../lib/string-utils')\n\nvar Conversation = require('../models/conversation')\n\n/**\n * Snapchat wrapper for chat-related API calls.\n *\n * @class\n * @param {Object} opts\n */\nfunction Chat (client, opts) {\n  var self = this\n  if (!(self instanceof Chat)) return new Chat(client, opts)\n  if (!opts) opts = {}\n\n  self.client = client\n}\n\n/**\n * Sends the typing notification to the given users.\n *\n * @param {Array<string>} recipients An array of username strings.\n * @param {function} cb\n */\nChat.prototype.sendTypingToUsers = function (recipients, cb) {\n  var self = this\n  debug('Chat.sendTypingToUsers')\n\n  return self._sendTyping(recipients, cb)\n}\n\n/**\n * Sends the typing notification to a single user.\n *\n * @param {string} username\n * @param {function} cb\n */\nChat.prototype.sendTypingToUser = function (username, cb) {\n  var self = this\n  debug('Chat.sendTypingToUser (%s)', username)\n\n  return self._sendTyping([ username ], cb)\n}\n\n/**\n * Marks all chat messages in a conversation as read.\n *\n * @TODO currently not working\n * @param {Conversation} conversation\n * @param {function} cb\n */\nChat.prototype.markRead = function (conversation, cb) {\n  var self = this\n  debug('Chat.markRead (%s)', conversation.identifier)\n\n  return self.client.sendEvents([\n    {\n      'eventName': 'CHAT_TEXT_VIEWED',\n      'params': {\n        'id': conversation.identifier\n      },\n      'ts': StringUtils.timestamp() | 0\n    }\n  ], null, cb)\n}\n\n/**\n * Retrieves the conversation auth mac and payload for a conversation with username.\n *\n * @param {string} username\n * @param {function} cb\n */\nChat.prototype.conversationAuth = function (username, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Chat.conversationAuth (%s)', username)\n\n    var cid = StringUtils.SCIdentifier(self.client.username, username)\n\n    self.client.post(constants.endpoints.chat.authToken, {\n      'username': self.client.username,\n      'conversation_id': cid\n    }, function (err, result) {\n      if (err) {\n        return reject(err)\n      } else if (result) {\n        result = result['messaging_auth']\n\n        if (result && result['mac'] && result['payload']) {\n          return resolve(result)\n        }\n\n        return reject(new Error('Chat.conversationAuth parse error'))\n      }\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Retrieves the conversation with \\e username.\n *\n * @param {string} username\n * @param {function} cb\n */\nChat.prototype.conversationWithUser = function (username, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Chat.conversationWithUser (%s)', username)\n\n    self.conversationsWithUsers([ username ], function (err, results) {\n      if (err) {\n        return reject(err)\n      } else {\n        return resolve(results.conversations[0])\n      }\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Fetches the conversations for all users in \\e usernames\n *\n * @param {Array<string>} usernames\n * @param {function} cb\n */\nChat.prototype.conversationsWithUsers = function (usernames, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Chat.conversationsWithUsers (%j)', usernames)\n\n    var results = {\n      conversations: [ ],\n      failed: [ ],\n      errors: [ ]\n    }\n\n    var messages = [ ]\n\n    async.eachLimit(usernames, 4, function (username, cb) {\n      self.conversationAuth(username, function (err, auth) {\n        if (err) {\n          results.failed.push(username)\n          results.errors.push(err)\n          return cb(err)\n        } else {\n          var identifier = StringUtils.uniqueIdentifer()\n          var header = {\n            'auth': auth,\n            'to': [ username ],\n            'conv_id': StringUtils.SCIdentifier(self.client.username, username),\n            'from': self.client.username,\n            'conn_sequence_number': 0\n          }\n\n          var first = {\n            'presences': { },\n            'receiving_video': false,\n            'supports_here': true,\n            'header': header,\n            'retried': false,\n            'id': identifier,\n            'type': 'presence'\n          }\n\n          first.presences[self.client.username] = true\n          first.presences[username] = false\n\n          var header2 = extend(header, {\n            'conv_id': StringUtils.SCIdentifier(username, self.client.username)\n          })\n\n          var second = {\n            'presences': { },\n            'receiving_video': false,\n            'supports_here': true,\n            'header': header2,\n            'retried': false,\n            'id': identifier,\n            'type': 'presence'\n          }\n\n          second.presences[self.client.username] = true\n          second.presences[username] = false\n\n          messages.push(first)\n          messages.push(second)\n          return cb(null)\n        }\n      })\n    }, function () {\n      self.client.post(constants.endpoints.chat.sendMessage, {\n        'auth_token': self.client.authToken,\n        'messages': JSON.stringify(messages),\n        'username': self.client.username\n      }, function (err, result) {\n        if (err) {\n          return reject(err)\n        } else if (result) {\n          if (result.conversations) {\n            results.conversations = result.conversations.map(function (convo) {\n              return new Conversation(convo)\n            })\n            return resolve(results)\n          } else {\n            debug('Chat.conversationsWithUsers parse error %j', result)\n          }\n        }\n\n        return reject(new Error('Chat.conversationsWithUsers parse error'))\n      })\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Clears the conversation with the given identifier.\n *\n * @param {string} identifier The identifier of the conversation to clear.\n * @param {function} cb\n */\nChat.prototype.clearConversationWithIdentifier = function (identifier, cb) {\n  var self = this\n  debug('Chat.clearConversationWithIdentifier (%s)', identifier)\n\n  return self.client.post(constants.endpoints.chat.clearConvo, {\n    'conversation_id': identifier,\n    'username': self.client.username\n  }, cb)\n}\n\n/**\n * Clears the entire feed.\n *\n * @param {function} cb\n */\nChat.prototype.clearFeed = function (cb) {\n  var self = this\n  debug('Chat.clearFeed')\n\n  return self.client.post(constants.endpoints.chat.clearFeed, {\n    'username': self.client.username\n  }, cb)\n}\n\n/**\n * Sends a message \\e message to \\e username.\n *\n * @param {string} message The message to send.\n * @param {Array<string>} username The username of the recipient.\n * @param {function} cb\n */\nChat.prototype.sendMessage = function (message, username, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Chat.sendMessage (\"%s\", %s)', message, username)\n\n    self.sendMessageToUsers(message, [ username ], function (err, results) {\n      if (err) {\n        return reject(err)\n      } else if (!results.conversations.length) {\n        return reject(new Error('Chat.conversationWithUser error'))\n      } else {\n        return resolve(results.conversations[0])\n      }\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Sends a message \\e message to each user in \\e usernames.\n *\n * @TODO: what to do if message fails to send\n *\n * @param {string} message The message to send.\n * @param {Array<string>} usernames An array of username strings as recipients.\n * @param {function} cb\n */\nChat.prototype.sendMessageToUsers = function (message, usernames, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Chat.sendMessageToUsers (\"%s\", %j)', message, usernames)\n\n    var results = {\n      conversations: [ ],\n      failed: [ ],\n      errors: [ ]\n    }\n\n    self.conversationsWithUsers(usernames, function (err, convoResults) {\n      if (err) {\n        return reject(err)\n      }\n\n      results.failed = convoResults.failed\n      results.errors = convoResults.errors\n\n      var messages = convoResults.conversations.map(function (convo) {\n        var identifier = StringUtils.uniqueIdentifer()\n        var sequenceNum = convo.state['conversation_state']\n        sequenceNum = sequenceNum && sequenceNum['user_sequences']\n        sequenceNum = sequenceNum && sequenceNum[self.client.username]\n        sequenceNum = sequenceNum | 0\n\n        var header = {\n          'auth': convo.messagingAuth,\n          'to': [ convo.recipient ],\n          'from': self.client.username,\n          // 'conn_sequence_number': 1,\n          'conn_sequ_num': 1,\n          'conv_id': convo.identifier\n        }\n\n        return {\n          'body': { 'type': 'text', 'text': message },\n          'chat_message_id': identifier,\n          'seq_num': sequenceNum + 1,\n          'timestamp': StringUtils.timestamp(),\n          'retried': false,\n          'id': identifier,\n          'type': 'chat_message',\n          'header': header\n        }\n      })\n\n      if (!messages.length) {\n        debug('Chat.sendMessageToUsers error retrieving conversations')\n        return reject(new Error('Chat.sendMessageToUsers error retrieving conversations'))\n      } else {\n        self.client.post(constants.endpoints.chat.sendMessage, {\n          'auth_token': self.client.authToken,\n          'messages': JSON.stringify(messages),\n          'username': self.client.username\n        }, function (err, result) {\n          if (err) {\n            return reject(err)\n          } else if (result) {\n            if (result.conversations && result.conversations) {\n              results.conversations = result.conversations.map(function (convo) {\n                return new Conversation(convo)\n              })\n              return resolve(results)\n            } else {\n              debug('Chat.sendMessageToUsers parse error %j', result)\n            }\n          }\n\n          return reject(new Error('Chat.sendMessageToUsers parse error'))\n        })\n      }\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Loads another page of conversations in the feed after the given conversation.\n *\n * This method will update client.session.conversations accordingly.\n *\n * @param {Conversation} conversation The conversation after which to load more conversations.\n * @param {function} cb\n */\nChat.prototype.loadConversationsAfter = function (conversation, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Chat.loadConversationsAfter')\n\n    if (!conversation || !conversation.pagination || !conversation.pagination.length) {\n      return resolve([ ])\n    }\n\n    self.client.post(constants.endpoints.chat.conversations, {\n      'username': self.client.username,\n      'checksum': StringUtils.md5HashToHex(self.client.username),\n      'offset': conversation.pagination\n    }, function (err, result) {\n      if (err) {\n        return reject(err)\n      } else if (result) {\n        result = result['conversations_response']\n\n        if (result) {\n          var conversations = result.map(function (result) {\n            var convo = new Conversation(result)\n\n            self.client.session.conversations.push(convo)\n            return convo\n          })\n\n          return resolve(conversations)\n        }\n\n        return reject(new Error('Chat.loadConversationsAfter parse error'))\n      }\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Loads all conversations into the current session.\n *\n * This method will update client.session.conversations accordingly.\n * @param {function} cb\n */\nChat.prototype.loadAllConversations = function (cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Chat.loadAllConversations')\n\n    self.client.updateSession(function (err) {\n      if (err) {\n        return reject(err)\n      }\n\n      var conversations = [ ]\n      var last = self.client.session.conversations[self.client.session.conversations.length - 1]\n\n      function loadPage () {\n        self.loadConversationsAfter(last, function (err, convos) {\n          if (err) {\n            return reject(err)\n          } else if (convos.length > 0) {\n            conversations = conversations.concat(convos)\n            last = convos[convos.length - 1]\n            return loadPage()\n          }\n\n          conversations.forEach(function (convo) {\n            self.client.session.conversations.push(convo)\n          })\n          return resolve(conversations)\n        })\n      }\n\n      loadPage()\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Loads more messages after the given message or cash transaction.\n *\n * @param {Transaction|Message} messageOrTransaction any object conforming to Pagination \\b EXCEPT AN \\C Conversation.\n * @warning Do not pass an Conversation object to messageOrTransaction. Doing so will throw an exception.\n * @param {function} cb\n */\nChat.prototype.loadMessagesAfterPagination = function (messageOrTransaction, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Chat.loadMessagesAfterPagination')\n\n    if (messageOrTransaction instanceof Conversation ||\n       !messageOrTransaction.conversationIdentifier) {\n      return reject(new Error('Chat.loadMessagesAfterPagination invalid param'))\n    }\n\n    if (!messageOrTransaction ||\n        !messageOrTransaction.pagination ||\n        !messageOrTransaction.pagination.length) {\n      return resolve()\n    }\n\n    self.clients.post(constants.endpoints.chat.conversation, {\n      'username': self.client.username,\n      'conversation_id': messageOrTransaction.conversationIdentifier,\n      'offset': messageOrTransaction.pagination\n    }, function (err, result) {\n      if (err) {\n        return reject(err)\n      } else if (result && result.conversation) {\n        return resolve(new Conversation(result.conversation))\n      }\n\n      return reject(new Error('Chat.loadConversationsAfter parse error'))\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Loads all messages in the given thread and adds them to that Conversation object.\n *\n * @param {Conversation} conversation The conversation to load completely.\n * @param {function} cb\n */\nChat.prototype.loadFullConversation = function (conversation, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Chat.loadFullConversation')\n\n    var last = conversation.messages[conversation.messages.length - 1]\n\n    function loadPage () {\n      self.loadMessagesAfterPagination(last, function (err, convo) {\n        if (err) {\n          return reject(err)\n        } else if (convo) {\n          last = convo.messages[convo.messages.length - 1]\n          conversation.addMessagesFromConversation(convo)\n          return loadPage()\n        }\n\n        return resolve()\n      })\n    }\n\n    loadPage()\n  }).nodeify(cb)\n}\n\n/**\n * @private\n */\nChat.prototype._sendTyping = function (recipients, cb) {\n  var self = this\n\n  return self.client.post(constants.endpoints.chat.typing, {\n    'recipient_usernames': JSON.stringify(recipients),\n    'username': self.client.username\n  }, cb)\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/routes/device.js":"module.exports = Device\n\nvar debug = require('debug')('snapchat:device')\nvar Promise = require('bluebird')\n\nvar constants = require('../lib/constants')\nvar StringUtils = require('../lib/string-utils')\n\n/**\n * Snapchat wrapper for chat-related API calls.\n *\n * @class\n * @param {Object} opts\n */\nfunction Device (client, opts) {\n  var self = this\n  if (!(self instanceof Device)) return new Device(client, opts)\n  if (!opts) opts = {}\n\n  self.client = client\n}\n\n/**\n * Sends the \"app did open\" event to Snapchat.\n *\n * @param {function} cb\n */\nDevice.prototype.sendDidOpenAppEvent = function (cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Device.sendDidOpenAppEvent')\n\n    self.client.updateSession(function (err) {\n      if (err) {\n        return reject(err)\n      }\n\n      var uuid = StringUtils.uniqueIdentifer()\n      var friendCount = -1\n\n      self.client.session.friends.forEach(function (friend) {\n        if (friend.privacy === constants.SnapPrivacy.Friends) {\n          ++friendCount\n        }\n      })\n\n      var unimplemented = 'Unimplemented'\n      var timestamp = StringUtils.timestamp()\n\n      self.client.sendEvents({\n        'common_params': {\n          'user_id': StringUtils.md5HashToHex(self.client.username),\n          'city': unimplemented,\n          'sc_user_agent': constants.core.userAgent,\n          'session_id': '00000000-0000-0000-0000-000000000000',\n          'region': unimplemented,\n          'latlon': unimplemented,\n          'friend_count': friendCount,\n          'country': unimplemented\n        },\n        'events': [\n          {\n            'event_name': 'APP_OPEN',\n            'event_timestamp': timestamp,\n            'event_params': {\n              'open_state': 'NORMAL',\n              'intent_action': 'NULL'\n            }\n          }\n        ],\n        'batch_id': uuid + '-' + constants.core.userAgent.replace(/\\w+/, '') + timestamp\n      }, null, function (err, result) {\n        if (err) {\n          return reject(err)\n        }\n        return reject(result)\n      })\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Sends the \"app did close\" event to Snapchat.\n *\n * @param {function} cb\n */\nDevice.prototype.sendDidCloseAppEvent = function (cb) {\n  var self = this\n  debug('Device.sendDidCloseAppEvent')\n\n  return self.client.sendEvents([\n    {\n      'eventName': 'CLOSE',\n      'params': { },\n      'ts': StringUtils.timestamp()\n    }\n  ], null, cb)\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/routes/friends.js":"module.exports = Friends\n\nvar debug = require('debug')('snapchat:friends')\nvar Promise = require('bluebird')\n\nvar constants = require('../lib/constants')\n\nvar FoundFriend = require('../models/found-friend')\nvar NearbyUser = require('../models/nearby-user')\nvar User = require('../models/user')\n\n/**\n * Friends wrapper for friends-related API calls.\n *\n * @class\n * @param {Object} opts\n */\nfunction Friends (client, opts) {\n  var self = this\n  if (!(self instanceof Friends)) return new Friends(client, opts)\n  if (!opts) opts = {}\n\n  self.client = client\n}\n\n/**\n * Adds the users in toAdd as friends, and unfriends the users in toUnfriend.\n *\n * @param {Array<string>} toAdd An array of username strings of users to add. Doesn't matter if they're already in your friends.\n * @param {Array<string>} toUnfriend An array of username strings of users to un-friend. Doesn't matter if they're not already in your friends.\n * @param {function} cb\n */\nFriends.prototype.addFriends = function (toAdd, toUnfriend, cb) {\n  var self = this\n  debug('Friends.addFriends (toAdd %j, toUnfriend %j)', toAdd, toUnfriend)\n\n  if (!toAdd) toAdd = []\n  if (!toUnfriend) toUnfriend = []\n\n  return self.client.post(constants.endpoints.friends.friend, {\n    'username': self.client.username,\n    'action': 'multiadddelete',\n    'friend': {\n      friendsToAdd: JSON.stringify(toAdd),\n      friendsToDelete: JSON.stringify(toUnfriend)\n    },\n    'added_by': 'ADDED_BY_USERNAME'\n  }, cb)\n}\n\n/**\n * Adds username as a friend.\n *\n * @param {string} username The user to add.\n * @param {function} cb\n */\nFriends.prototype.addFriend = function (username, cb) {\n  var self = this\n  debug('Friends.addFriend (%s)', username)\n\n  return self.client.post(constants.endpoints.friends.friend, {\n    'action': 'add',\n    'friend': username,\n    'username': self.client.username,\n    'added_by': 'ADDED_BY_USERNAME'\n  }, cb)\n}\n\n/**\n * Use this to add back a user who has added you as a friend. Sort of like accepting a friend request.\n *\n * This only affects the \"added by\" string the other user will see.\n * @param {string} username The username of the user to add back.\n * @param {function} cb\n */\nFriends.prototype.addFriendBack = function (username, cb) {\n  var self = this\n  debug('Friends.addFriendBack (%s)', username)\n\n  return self.client.post(constants.endpoints.friends.friend, {\n    'action': 'add',\n    'friend': username,\n    'username': self.client.username,\n    'added_by': 'ADDED_BY_ADDED_ME_BACK'\n  }, cb)\n}\n\n/**\n * Unfriends username.\n *\n * @param {string} username The username of the user to unfriend.\n * @param {function} cb\n */\nFriends.prototype.unfriend = function (username, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Friends.unfriend (%s)', username)\n\n    self.client.post(constants.endpoints.friends.friend, {\n      'action': 'delete',\n      'friend': username,\n      'username': self.client.username\n    }, function (err) {\n      if (err) {\n        return reject(err)\n      }\n\n      self._removeFriendsFromSession([ { username: username } ])\n      return resolve()\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Finds friends given phone numbers and names.\n *\n * friends is a number->name map, where \"name\" is the desired screen name of that friend and \"number\" is their phone number.\n * The names given will be used as display names for any usernames found.\n *\n * @param {Object} friends a dictionary with phone number strings as the keys and name strings as the values.\n * @param {function} cb\n */\nFriends.prototype.findFriends = function (friends, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Friends.findFriends (%j)', friends)\n\n    if (self.client.session.shouldTextToVerifyNumber ||\n        self.client.session.shouldCallToVerifyNumber) {\n      return reject(new Error('Friends.findFriends error client needs to verify phone first'))\n    }\n\n    self.client.post(constants.endpoints.friends.find, {\n      'username': self.client.username,\n      'countryCode': self.client.session.countryCode,\n      'numbers': JSON.stringify(friends)\n    }, function (err, result) {\n      if (err) {\n        return reject(err)\n      } else if (result && result.results) {\n        var results = result.results.map(function (friend) {\n          return new FoundFriend(friend)\n        })\n        return resolve(results)\n      }\n\n      return reject(new Error('Friends.findFriends parse error'))\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Finds nearby snapchatters who are also looking for nearby snapchatters.\n *\n * @param {Object} location The location to search from { lat, lng }.\n * @param {number} accuracy The radius in meters to find nearby snapchatters at location. Defaults to 10.\n * @param {number} milliseconds The total poll duration so far. If you're polling in a for-loop for example, pass the time in milliseconds since you started polling. This has been guess-work, but I think it's right.\n * @param {function} cb\n */\nFriends.prototype.findFriendsNear = function (location, accuracy, milliseconds, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Friends.findFriendsNear (%j)', location)\n\n    if (accuracy <= 0) accuracy = 10\n\n    self.client.post(constants.endpoints.friends.findNearby, {\n      'username': self.client.username,\n      'accuracyMeters': accuracy,\n      'action': 'update',\n      'lat': location.lat,\n      'lng': location.lng,\n      'totalPollingDurationMillis': milliseconds\n    }, function (err, result) {\n      if (err) {\n        return reject(err)\n      } else if (result && result['nearby_snapchatters']) {\n        var results = result['nearby_snapchatters'].map(function (user) {\n          return new NearbyUser(user['username'], user['user_id'])\n        })\n        return resolve(results)\n      }\n\n      return reject(new Error('Friends.findFriendNear parse error'))\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Not sure what this is for.\n */\nFriends.prototype.searchFriend = function (query, cb) {\n  var self = this\n  debug('Friends.searchFriend (%s)', query)\n\n  return self.client.post(constants.endpoints.friends.search, {\n    'query': query,\n    'username': self.client.username\n  }, cb)\n}\n\n/**\n * Checks to see whether username is a registered username.\n *\n * @param {string} username\n * @param {function} cb\n */\nFriends.prototype.userExists = function (username, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Friends.userExists (%s)', username)\n\n    self.client.post(constants.endpoints.friends.exists, {\n      'request_username': username,\n      'username': self.client.username\n    }, function (err, result) {\n      if (err) {\n        return reject(err)\n      } else if (result) {\n        return resolve(!!result.exists)\n      }\n\n      return reject(new Error('Friends.userExists parse error'))\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Updates the display name for one of your friends.\n *\n * @param {string} friend The username to give the new display name to.\n * @param {string} displayName The new display name.\n * @param {function} cb\n */\nFriends.prototype.updateDisplayNameForUser = function (friend, displayName, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Friends.updateDisplayNameForUser (%s, \"%s\")', friend, displayName)\n\n    self.client.post(constants.endpoints.friends.friend, {\n      'action': 'display',\n      'display': displayName,\n      'friend': friend,\n      'friend_id': '',\n      'username': self.client.username\n    }, function (err, result) {\n      if (err) {\n        return reject(err)\n      } else if (result && result.object) {\n        var updated = new User(result.object)\n\n        self._removeFriendsFromSession([ updated ])\n        self._addFriendsToSession([ updated ])\n        return resolve(updated)\n      } else {\n        debug('Friends.updateDisplayNameForUser parse error %j', result)\n      }\n\n      return reject(new Error('Friends.updateDisplayNameForUser parse error'))\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Blocks username.\n *\n * @param {string} username The username of the user to block.\n * @param {function} cb\n */\nFriends.prototype.blockUser = function (username, cb) {\n  var self = this\n  debug('Friends.blockUser (%s)', username)\n\n  return self._setUserBlocked(username, true, cb)\n}\n\n/**\n * Unblocks username.\n *\n * @param {string} username The username of the user to block.\n * @param {function} cb\n */\nFriends.prototype.unblockUser = function (username, cb) {\n  var self = this\n  debug('Friends.unblockUser (%s)', username)\n\n  return self._setUserBlocked(username, false, cb)\n}\n\n/**\n * This appears to be for an upcoming feature: suggested friends?\n *\n * @param {Array<string>} usernames.\n * @param {boolean} seen Whether to mark as seen.\n * @param {function} cb\n */\nFriends.prototype.seenSuggestedFriends = function (usernames, seen, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Friends.seenSuggestedFriends (%j, %d)', usernames, seen)\n\n    if (!usernames || !usernames.length) usernames = [ ]\n\n    self.client.post(constants.endpoints.misc.suggestFriend, {\n      'action': 'update',\n      'seen': !!seen,\n      'seen_suggested_friend_list': JSON.stringify(usernames),\n      'username': self.client.username\n    }, function (err, result) {\n      if (err) {\n        return reject(err)\n      } else if (result) {\n        return resolve(!!result.logged)\n      }\n\n      return reject(new Error('Friends.seenSuggestedFriends parse error'))\n    })\n  }).nodeify(cb)\n}\n\n/**\n * @private\n *\n * @param {Array<User>} friends\n */\nFriends.prototype._removeFriendsFromSession = function (friends) {\n  var self = this\n  var friendsMap = { }\n\n  friends.forEach(function (friend) {\n    friendsMap[friend.username] = true\n  })\n\n  self.client.session.friends = self.client.session.friends.filter(function (friend) {\n    return !(friend.username in friendsMap)\n  })\n}\n\n/**\n * @private\n *\n * @param {Array<User>} friends\n */\nFriends.prototype._addFriendsToSession = function (friends) {\n  var self = this\n  self.client.session.friends = self.client.session.friends.concat(friends)\n}\n\n/**\n * @private\n *\n * @param {string} username\n * @param {boolean} blocked\n * @param {function} cb\n */\nFriends.prototype._setUserBlocked = function (username, blocked, cb) {\n  var self = this\n\n  return self.client.post(constants.endpoints.friends.friend, {\n    'action': blocked ? 'block' : 'unblock',\n    'friend': username,\n    'username': self.client.username\n  }, cb)\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/routes/snaps.js":"module.exports = Snaps\n\nvar debug = require('debug')('snapchat:snaps')\nvar Promise = require('bluebird')\n\nvar constants = require('../lib/constants')\nvar StringUtils = require('../lib/string-utils')\nvar Request = require('../lib/request')\n\nvar SnapOptions = require('../models/snap-options')\nvar SKBlob = require('../models/blob')\nvar SKLocation = require('../models/location')\n\n/**\n * Snapchat wrapper for Snap-related API calls.\n *\n * @class\n * @param {Object} opts\n */\nfunction Snaps (client, opts) {\n  var self = this\n  if (!(self instanceof Snaps)) return new Snaps(client, opts)\n  if (!opts) opts = {}\n\n  self.client = client\n}\n\n/**\n * Sends a snap to everyone in recipients with text text for duration seconds.\n *\n * @param {SKBlob} blob The SKBlob object containing the image or video data to send. Can be created with any NSData object.\n * @param {Array<string>|string} recipients An array of username strings.\n * @param {string} text The text to label the snap with. This text is not superimposed upon the image; you must do that yourself.\n * @param {number} duration The length of the snap. It must be greater than 0 or an exception will be raised.\n * @param {function} cb\n */\nSnaps.prototype.sendSnap = function (blob, recipients, text, duration, cb) {\n  var self = this\n  debug('Snaps.sendSnap')\n\n  return self.sendSnapCustom(blob, new SnapOptions(recipients, text, duration), cb)\n}\n\n/**\n * Sends a snap with the given options.\n *\n * @param {SKBlob} blob The SKBlob object containing the image or video data to send. Can be created with any Buffer.\n * @param {SnapOptions} opts The options for the snap to be sent.\n * @param {function} cb\n */\nSnaps.prototype.sendSnapCustom = function (blob, opts, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Snaps.sendSnapCustom')\n\n    self._uploadSnap(blob, function (err, mediaID) {\n      if (err) {\n        return reject(err)\n      }\n\n      self.client.post(constants.endpoints.snaps.send, {\n        'camera_front_facing': !!opts.cameraFrontFacing,\n        'country_code': self.client.session.countryCode,\n        'media_id': mediaID,\n        'recipients': JSON.stringify(opts.recipients),\n        'recipient_ids': JSON.stringify(opts.recipients),\n        'reply': !!opts.isReply,\n        'time': +opts.timer,\n        'zipped': 0,\n        'username': self.client.username\n      }, function (err, result) {\n        if (err) {\n          return reject(err)\n        }\n        return resolve(result)\n      })\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Marks a snap as opened for secondsViewed seconds.\n *\n * @param {number} secondsViewed The number of seconds the snap was viewed for.\n * @param {function} cb\n */\nSnaps.prototype.markSnapViewed = function (snap, secondsViewed, cb) {\n  var self = this\n  debug('Snaps.markSnapViewed')\n\n  return self.markSnapsViewed([ snap ], [ new Date() ], [ secondsViewed ], cb)\n}\n\n/**\n * Marks a set of snaps as opened for the specified length at the given times.\n *\n * @param {Array<SKSnap>} snaps An array of SKSnap objects.\n * @param {Array<Date>} times An array of Date objects.\n * @param {Array<number>} secondsViewed An array of numbers.\n * @param {function} cb\n */\nSnaps.prototype.markSnapsViewed = function (snaps, times, secondsViewed, cb) {\n  var self = this\n  debug('Snaps.markSnapsViewed')\n\n  if (snaps.length !== times.length || times.length !== secondsViewed.length) {\n    throw new Error('Snaps.markSnapsViewed all arrays must have the same length')\n  }\n\n  var json = { }\n\n  snaps.forEach(function (snap, index) {\n    json[snap.identifier] = {\n      't': StringUtils.timestampFrom(times[index]),\n      'sv': secondsViewed[index]\n    }\n  })\n\n  return self.client.post(constants.endpoints.update.snaps, {\n    'added_friends_timestamp': StringUtils.timestampFrom(self.session.addedFriendsTimestamp),\n    'username': self.client.username,\n    'json': JSON.stringify(json)\n  }, cb)\n}\n\n/**\n * Marks a snap as screenshotted and viewed for secondsViewed seconds.\n *\n * @param {number} secondsViewed The number of seconds the snap was viewed for.\n * @param {function} cb\n */\nSnaps.prototype.markSnapScreenshot = function (snap, secondsViewed, cb) {\n  var self = this\n  debug('Snaps.markSnapScreenshot')\n\n  var timestamp = StringUtils.timestamp()\n  var snapInfo = { }\n\n  snapInfo[snap.identifier] = {\n    't': timestamp | 0,\n    'sv': secondsViewed,\n    'c': constants.SnapStatus.Screenshot\n  }\n\n  var screenshot = {\n    'eventName': 'SNAP_SCREENSHOT',\n    'params': {\n      'id': snap.identifier\n    },\n    'ts': StringUtils.timestamp() | 0\n  }\n\n  return self.client.sendEvents([ screenshot ], snapInfo, cb)\n}\n\n/**\n * Loads a snap.\n *\n * @param {Snap} snap\n * @param {function} cb\n */\nSnaps.prototype.loadSnap = function (snap, cb) {\n  var self = this\n  debug('Snaps.loadSnap')\n\n  return self._loadSnapWithIdentifier(snap.identifier, cb)\n}\n\n/**\n * Loads filters for a location.\n *\n * @param {Object} location { lat, lng }\n * @param {function} cb\n */\nSnaps.prototype.loadFiltersForLocation = function (location, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Snaps.loadFiltersForLocation')\n\n    self.client.post(constants.endpoints.misc.locationData, {\n      'lat': location.lat,\n      'lng': location.lng,\n      'screen_width': self.client.screenSize.width,\n      'screen_height': self.client.screenSize.height,\n      'username': self.client.username\n    }, function (err, result) {\n      if (err) {\n        return reject(err)\n      } else if (result) {\n        return resolve(new SKLocation(result))\n      }\n\n      return reject(new Error('Snaps.loadFiltersForLocation parse error'))\n    })\n  }).nodeify(cb)\n}\n\n/**\n * @private\n */\nSnaps.prototype._loadSnapWithIdentifier = function (identifier, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    self.client.post(constants.endpoints.snaps.loadBlob, {\n      'id': identifier,\n      'username': self.client.username\n    }, function (err, body) {\n      if (err) {\n        return reject(err)\n      }\n\n      SKBlob.initWithData(body, function (err, blob) {\n        if (err) {\n          return reject(err)\n        }\n        return resolve(blob)\n      })\n    })\n  }).nodeify(cb)\n}\n\n/**\n * @private\n * @param {SKBlob} blob\n * @param {function} cb\n */\nSnaps.prototype._uploadSnap = function (blob, cb) {\n  var self = this\n  var uuid = StringUtils.mediaIdentifier(self.client.username)\n\n  if (!(blob instanceof SKBlob)) {\n    throw new Error('Snap._uploadSnap invalid argument \"blob\" must be SKBlob instance')\n  }\n\n  var params = {\n    'media_id': uuid,\n    'type': blob.isImage ? constants.MediaKind.Image.value : constants.MediaKind.Video.value,\n    'data': blob.data,\n    'zipped': 0,\n    'features_map': '{}',\n    'username': self.client.username\n  }\n\n  var headers = { }\n  headers[constants.headers.clientAuthToken] = 'Bearer ' + self.client.googleAuthToken\n  headers[constants.headers.contentType] = 'multipart/form-data; boundary=' + constants.core.boundary\n\n  Request.postCustom(constants.endpoints.snaps.upload, params, headers, self.client.authToken, function (err) {\n    if (err) {\n      return cb(err)\n    } else {\n      return cb(null, uuid)\n    }\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-snapchat/node_modules/snapchat/routes/stories.js":"module.exports = Stories\n\nvar qs = require('querystring')\n\nvar debug = require('debug')('snapchat:stories')\nvar async = require('async')\nvar Promise = require('bluebird')\n\nvar constants = require('../lib/constants')\nvar Request = require('../lib/request')\nvar StringUtils = require('../lib/string-utils')\n\nvar SKBlob = require('../models/blob')\nvar StoryUpdater = require('../models/story-updater')\nvar SharedStoryDescription = require('../models/shared-story-description')\n\n/**\n * Snapchat wrapper for story-related API calls.\n *\n * @class\n * @param {Object} opts\n */\nfunction Stories (client, opts) {\n  var self = this\n  if (!(self instanceof Stories)) return new Stories(client, opts)\n  if (!opts) opts = {}\n\n  self.client = client\n}\n\n/**\n * Posts a story with the given options.\n *\n * @param {Blob} blob The Blob object containing the image or video data to send.\n * @param {StoryOptions} opts The options for the story to post.\n * @param {function} cb\n */\nStories.prototype.postStory = function (blob, opts, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Stories.postStory')\n\n    self._uploadStory(blob, function (err, mediaID) {\n      if (err) {\n        debug('Snapchat.Stories.postStory error %s', err)\n        return reject(err)\n      }\n\n      self.client.post(constants.endpoints.stories.post, {\n        'caption_text_display': opts.text,\n        'story_timestamp': StringUtils.timestamp(),\n        'type': blob.isImage ? constants.MediaKind.Image : constants.MediaKind.Video,\n        'media_id': mediaID,\n        'client_id': mediaID,\n        'time': opts.timer | 0,\n        'username': self.client.username,\n        'camera_front_facing': opts.cameraFrontFacing,\n        'my_story': 'true',\n        'zipped': 0,\n        'shared_ids': '{}'\n      }, function (err, result) {\n        if (err) {\n          debug('Snapchat.Stories.postStory error %s', err)\n          return reject(err)\n        } else if (result) {\n          return resolve(result)\n        }\n\n        return reject(new Error('Snapchat.Stories.postStory parse error'))\n      })\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Downloads media for a story.\n *\n * @param {Story} story The story to download.\n * @param {function} cb SKBlob\n */\nStories.prototype.loadStoryBlob = function (story, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Stories.loadStoryBlob (%s)', story.identifier)\n\n    function blobHandler (err, body) {\n      if (err) {\n        debug('Snapchat.Stories.loadStoryBlob error %s', err)\n        return reject(err)\n      }\n\n      SKBlob.initWithStoryData(body, story, function (err, blob) {\n        if (err) {\n          return reject(err)\n        }\n        return resolve(blob)\n      })\n    }\n\n    if (story.needsAuth) {\n      var url = constants.endpoints.stories.authBlob + story.mediaIdentifier\n\n      Request.post(url, {\n        'story_id': story.mediaIdentifier,\n        'username': self.client.username\n      }, self.client.googleAuthToken, self.client.authToken, blobHandler)\n    } else {\n      var baseIgnorePattern = new RegExp(constants.core.baseList.join('|'))\n      self.client.get(story.mediaURL.replace(baseIgnorePattern, ''), blobHandler)\n    }\n  }).nodeify(cb)\n}\n\n/**\n * Downloads the thumbnail for a story.\n *\n * @param story The story whose thumbnail you wish to download.\n * @param {function} cb SKBlob\n */\nStories.prototype.loadStoryThumbnailBlob = function (story, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Stories.loadStoryThumbnailBlob (%s)', story.identifier)\n\n    self.client.get(constants.endpoints.stories.thumb + story.mediaIdentifier, function (err, body) {\n      if (err) {\n        debug('Snapchat.Stories.loadStoryThumbnailBlob error %s', err)\n        return reject(err)\n      }\n\n      SKBlob.initWithStoryData(body, story, function (err, blob) {\n        if (err) {\n          return reject(err)\n        }\n        return resolve(blob)\n      })\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Batch loads media for a set of stories.\n *\n * @param {Array<Story>} stories An array of Story objects whose media you wish to download.\n * @param {function} cb\n */\nStories.prototype.loadStories = function (stories, cb) {\n  debug('Stories.loadStories (%d)', stories.length)\n\n  return new Promise(function (resolve, reject) {\n    var results = {\n      loaded: [ ],\n      failed: [ ],\n      errors: [ ]\n    }\n\n    async.eachLimit(stories, 4, function (story, cb) {\n      story.load(function (err) {\n        if (err) {\n          results.failed.push(story)\n          results.errors.push(err)\n        } else {\n          results.loaded.push(story)\n        }\n\n        return cb(err)\n      })\n    }, function (err) {\n      if (err) {\n        return reject(err)\n      }\n      return resolve(results)\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Deletes a story of yours.\n *\n * @param {UserStory} story\n * @param {function} cb\n */\nStories.prototype.deleteStory = function (story, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Stories.deleteStory (%s)', story.identifier)\n\n    self.client.post(constants.endpoints.stories.remove, {\n      'story_id': story.identifier,\n      'username': self.client.username\n    }, function (err) {\n      if (err) {\n        return reject(err)\n      }\n      var index = self.client.session.userStories.indexOf(story)\n      if (index >= 0) {\n        self.client.session.userStories.splice(index, 1)\n      }\n      return resolve()\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Marks a set of stories as opened.\n *\n * @param {Array<StoryUpdater>} stories An array of StoryUpdater objects.\n * @param {function} cb\n */\nStories.prototype.markStoriesViewed = function (stories, cb) {\n  var self = this\n  debug('Stories.markStoriesViewed (%d)', stories.length)\n\n  var friendStories = stories.map(function (update) {\n    return {\n      'id': update.storyID,\n      'screenshot_count': update.screenshotCount,\n      'timestamp': update.timestamp\n    }\n  })\n\n  return self.client.post(constants.endpoints.update.stories, {\n    'username': self.client.username,\n    'friend_stories': JSON.stringify(friendStories)\n  }, cb)\n}\n\n/**\n * Marks a single story opened.\n * To batch mark stories viewed, use markStoriesViewed\n *\n * @param {Story} story The story to mark as opened.\n * @param {number} sscount The number of times the story was screenshotted.\n * @param {function} cb\n */\nStories.prototype.markStoryViewed = function (story, sscount, cb) {\n  var self = this\n  debug('Stories.markStoryViewed (%s)', story.identifier)\n\n  return self.markStoriesViewed([\n    new StoryUpdater(story.identifier, StringUtils.timestamp(), sscount)\n  ], cb)\n}\n\n/**\n * Hides a shared story from the story feed.\n *\n * @param {function} cb\n */\nStories.prototype.hideSharedStory = function (story, cb) {\n  var self = this\n  debug('Stories.hideSharedStory (%s)', story.identifier)\n\n  return self.client.post(constants.endpoints.friends.hide, {\n    'friend': story.username,\n    'hide': 'true',\n    'username': self.client.username\n  }, cb)\n}\n\n/**\n * Does nothing if the story is not a shared story.\n *\n * @param {Story} sharedStory A shared story.\n * @param {function} cb\n */\nStories.prototype.provideSharedDescription = function (sharedStory, cb) {\n  var self = this\n  debug('Stories.provideSharedDescription (%s)', sharedStory.identifier)\n  if (!sharedStory.shared) {\n    return Promise.reject(new Error('Snapchat.Stories.provideSharedDescription error')).nodeify(cb)\n  }\n\n  return self.client.post(constants.endpoints.sharedDescription, {\n    'shared_id': sharedStory.identifier,\n    'username': self.client.username\n  }, cb)\n}\n\n/**\n * Retrieves the description for a shared story.\n *\n * @param sharedStory A shared story.\n * @param {function} cb\n */\nStories.prototype.getSharedDescriptionForStory = function (sharedStory, cb) {\n  var self = this\n\n  return new Promise(function (resolve, reject) {\n    debug('Stories.getSharedDescriptionForStory (%s)', sharedStory.identifier)\n\n    if (!sharedStory.sharedStoryIdentifier) {\n      return reject(new Error('Snapchat.Stories.getSharedDescriptionForStory error invalid story'))\n    }\n\n    var endpoint = constants.endpoints.sharedDescription + '?' + qs.stringify({\n      'ln': 'en',\n      'shared_id': sharedStory.sharedStoryIdentifier\n    })\n\n    self.client.get(endpoint, function (err, result) {\n      if (err) {\n        return reject(err)\n      } else if (result) {\n        return resolve(new SharedStoryDescription(result))\n      }\n\n      return reject(new Error('Snapchat.Stories.getSharedDescriptionForStory parse error'))\n    })\n  }).nodeify(cb)\n}\n\n/**\n * Uploads a new story associated with the given blob.\n *\n * @private\n * @param {SKBlob} blob\n * @param {function} cb\n */\nStories.prototype._uploadStory = function (blob, cb) {\n  var self = this\n  var uuid = StringUtils.mediaIdentifer(self.client.username)\n\n  var params = {\n    'media_id': uuid,\n    'type': blob.isImage ? constants.MediaKind.Image : constants.MediaKind.Video,\n    'data': blob.data,\n    'zipped': 0,\n    'features_map': '{}',\n    'username': self.client.username\n  }\n\n  var headers = { }\n\n  headers[constants.headers.clientAuthToken] = 'Bearer ' + self.client.googleAuthToken\n  headers[constants.headers.contentType] = 'multipart/form-data; boundary=' + constants.core.boundary\n\n  return Request.postCustom(constants.endpoints.stories.upload, params, headers, self.client.authToken, cb)\n}\n"}